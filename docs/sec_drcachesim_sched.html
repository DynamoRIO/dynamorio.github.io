---
title: "Trace Scheduler"
layout: default
permalink: /sec_drcachesim_sched.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Trace Scheduler </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In addition to the analysis tool framework, which targets running multiple tools at once either in parallel across all traced threads or in a serial fashion, we provide a scheduler which will map inputs to a given set of outputs in a specified manner. This allows a tool such as a core simulator, or just a tool wanting its own control over advancing the trace stream (unlike the analysis tool framework where the framework controls the iteration), to request the next trace record for each output on its own. This scheduling is also available to any analysis tool when the input traces are sharded by core (see the <code>-core_sharded</code> and <code>-core_serial</code> and various <code>-sched_*</code> option documentation under <a class="el" href="sec_drcachesim_ops.html">Simulator Parameters</a> as well as core-sharded notes when <a class="el" href="sec_drcachesim_newtool.html">Creating New Analysis Tools</a>), and in fact is the default when all tools prefer core-sharded operation via <a class="el" href="classdynamorio_1_1drmemtrace_1_1analysis__tool__tmpl__t.html#a0bb572c2ab41e7d8fccaf6bfcb609ec2">dynamorio::drmemtrace::analysis_tool_t::preferred_shard_type()</a>.</p>
<h1><a class="anchor" id="sec_drcachesim_as_traced"></a>
As-Traced Schedule Limitations</h1>
<p>During tracing, marker records (see <a class="el" href="sec_drcachesim_format.html#sec_drcachesim_format_other">Other Records</a>) of type <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca0f5122cab14b6654b276de4aa7f8183c">dynamorio::drmemtrace::TRACE_MARKER_TYPE_CPU_ID</a> record the "as traced" schedule, indicating which threads were on which cores at which times. However, this schedule is not representative and should not be treated as indicating how the application behaves without tracing. In addition to only containing coarse-grain information at the top and bottom of trace buffers and missing any context switches occurring in the between, the indicated switches do not always correlate with where the untraced application would switch. This is due to tracing overhead, where heavyweight instrumentation is interspersed with application code and heavyweight i/o operations to write out the trace data cause delays. This extra overhead causes additional quantum preempts and additional switches due to blocking system calls for i/o. The resulting as-traced schedule can contain from 2x to 10x as many context switches as the untraced application. Consequently, we do not recommend using the as-traced schedule to study the application itself, though our scheduler does support replaying the as-traced schedule through the -cpu_schedule_file option.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_dynamic"></a>
Dynamic Scheduling</h1>
<p>Instead of using the as-traced schedule, we recommend re-scheduling the traced software threads using our trace scheduler in <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0ccaba192b7d617035b922db1f3960154406">dynamorio::drmemtrace::scheduler_t::MAP_TO_ANY_OUTPUT</a> mode. Our scheduler essentially serves as an operating system scheduler for this purpose, though using simpler schemes. It models separate runqueues per core with support for binding inputs to certain cores, priorities, idle time from blocking system calls, migration thresholds, rebalancing runqueues, etc. It exposes a number of knobs in the form of -sched_* parameters for the command-line <code>drmemtrace</code> launcher or programmatically through the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#acf6f9e344fed8627ff2868cfa7e34879">dynamorio::drmemtrace::scheduler_t</a> API.</p>
<p>Dynamic scheduling provides the following benefits:</p>
<ul>
<li>Deflation of the as-traced context switch rate (see <a class="el" href="sec_drcachesim_sched.html#sec_drcachesim_as_traced">As-Traced Schedule Limitations</a>) to provide a representative context switch rate.</li>
<li>Support for different numbers of cores than were present during tracing.</li>
<li>Multi-tenant support where separately traced applications are combined, with the dynamic scheduler interleaving them. This simulates a multi-tenant machine with a mix of processes running.</li>
</ul>
<p>The downsides include:</p>
<ul>
<li>Risk of incorrect ordering between application software threads. Today, our scheduler does use the in-trace timestamps (when requested via <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9afa1e39bbc41fe11cc3bbbd36b2a13e6e">dynamorio::drmemtrace::scheduler_t::DEPENDENCY_TIMESTAMPS</a>) to keep things in relative order. However, enforcing representative context switch rates is considered more important that honoring precise trace-buffer-based timestamp inter-input dependencies: thus, timestamp ordering will be followed at context switch points for picking the next input, but timestamps will not preempt an input.</li>
</ul>
<p>The <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca5935654bf36c3cb4e813ff0d8397e2ad">dynamorio::drmemtrace::TRACE_MARKER_TYPE_TIMESTAMP</a> and <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca0f5122cab14b6654b276de4aa7f8183c">dynamorio::drmemtrace::TRACE_MARKER_TYPE_CPU_ID</a> markers are modified by the dynamic scheduler to reflect the new schedule. The new timestamps maintain relative ordering but should not be relied upon to indicate accurate durations between events.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_time"></a>
Simulated Time</h1>
<p>As the simulator, rather than the scheduler, tracks simulated time, yet the scheduler needs to make some decisions based on time (such as when to preempt, when to migrate across cores, etc.), the simulator should pass in the current time when it queries the scheduler for the next record. The simulator tells the scheduler how many units of this simulated time comprise one microsecond so that the scheduler can scale its other parameters appropriately.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_idle"></a>
Idle Time</h1>
<p>The dynamic scheduler inserts markers of type <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295cabae8da1c6ba60323b5ef13fa55a799fc">dynamorio::drmemtrace::TRACE_MARKER_TYPE_CORE_IDLE</a> (with the tid field set to <a class="el" href="namespacedynamorio_1_1drmemtrace.html#addb5db6cd9a35b731ae9f0f3f3b174ba">dynamorio::drmemtrace::IDLE_THREAD_ID</a> when it is presented as a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">dynamorio::drmemtrace::memref_t</a> record) when there is no work available on a core, simulating actual idle time. This can happen even when there are inputs potentially available as the scheduler simulates i/o by blocking inputs from executing for a period of time when they make blocking system calls. This time is based on the system call latency recorded in the trace, but since this can be indirectly inflated due to tracing overhead the scheduler provides parameters to scale this time, exposed as <code>-sched_block_scale</code> and <code>-sched_block_max_us</code> to the <code>drmemtrace</code> launcher. These can be modified to try to achieve a desired level of idle time during simulation.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_replay"></a>
Record and Replay</h1>
<p>The scheduler supports recording a schedule and replaying it later, allowing for repeated execution of the same schedule. Timestamps in the recorded schedule help to align the cores during replay. If one gets too far ahead, markers of type <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca8d688aeae7d50e45269dbb8b494cbac1">dynamorio::drmemtrace::TRACE_MARKER_TYPE_CORE_WAIT</a> are inserted to indicate an artificial wait in order for the replay to get back on track.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_roi"></a>
Regions of Interest</h1>
<p>The scheduler supports running a subset of each input. A list of start and stop endpoints delimiting the regions of interest can be supplied with each input. The end result is as though the inputs had been edited to remove all content not inside the target regions.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_multi"></a>
Multiple Inputs</h1>
<p>The scheduler API supports multiple inputs from multiple workloads. This can be achieved in the drmemtrace analyzer framework in core-sharded mode with the -multi_indir option. The threads from every workload will all be interleaved together.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_speculation"></a>
Speculation Support</h1>
<p>The scheduler contains preliminary speculation support for wrong-path execution. Currently it only feeds nops, but future versions plan to fill in content based on prior trace paths.</p>
<h1><a class="anchor" id="sec_drcachesim_sched_ex"></a>
Scheduler Interface Example</h1>
<p>Here is a simple example of using the scheduler interface directly.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">simulate_core(scheduler_t::stream_t *stream)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">memref_t</a> record;</div>
<div class="line">    <span class="keywordflow">for</span> (scheduler_t::stream_status_t status = stream-&gt;next_record(record);</div>
<div class="line">         status != scheduler_t::STATUS_EOF; status = stream-&gt;next_record(record)) {</div>
<div class="line">        <span class="keywordflow">if</span> (status == scheduler_t::STATUS_WAIT || status == scheduler_t::STATUS_IDLE) {</div>
<div class="line">            std::this_thread::yield();</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        assert(status == scheduler_t::STATUS_OK);</div>
<div class="line">        <span class="comment">// Process &quot;record&quot; here.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">run_scheduler(<span class="keyword">const</span> std::string &amp;trace_directory)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacedynamorio_1_1drmemtrace.html#acf6f9e344fed8627ff2868cfa7e34879">scheduler_t</a> scheduler;</div>
<div class="line">    std::vector&lt;scheduler_t::input_workload_t&gt; sched_inputs;</div>
<div class="line">    sched_inputs.emplace_back(trace_directory);</div>
<div class="line">    scheduler_t::scheduler_options_t sched_ops(scheduler_t::MAP_TO_ANY_OUTPUT,</div>
<div class="line">                                               scheduler_t::DEPENDENCY_TIMESTAMPS,</div>
<div class="line">                                               scheduler_t::SCHEDULER_DEFAULTS);</div>
<div class="line">    constexpr <span class="keywordtype">int</span> NUM_CORES = 4;</div>
<div class="line">    <span class="keywordflow">if</span> (scheduler.init(sched_inputs, NUM_CORES, std::move(sched_ops)) !=</div>
<div class="line">        scheduler_t::STATUS_SUCCESS)</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    std::vector&lt;std::thread&gt; threads;</div>
<div class="line">    threads.reserve(NUM_CORES);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_CORES; ++i) {</div>
<div class="line">        threads.emplace_back(std::thread(&amp;simulate_core, scheduler.get_stream(i)));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (std::thread &amp;thread : threads)</div>
<div class="line">        thread.join();</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedynamorio_1_1drmemtrace_html_acf6f9e344fed8627ff2868cfa7e34879"><div class="ttname"><a href="namespacedynamorio_1_1drmemtrace.html#acf6f9e344fed8627ff2868cfa7e34879">dynamorio::drmemtrace::scheduler_t</a></div><div class="ttdeci">scheduler_tmpl_t&lt; memref_t, reader_t &gt; scheduler_t</div><div class="ttdef"><b>Definition:</b> scheduler.h:1389</div></div>
<div class="ttc" id="anamespacedynamorio_1_1drmemtrace_html_ae4a471ed806967b2b6f911b6ef770704"><div class="ttname"><a href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">dynamorio::drmemtrace::memref_t</a></div><div class="ttdeci">union dynamorio::drmemtrace::_memref_t memref_t</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 11.90.20482 --- Fri Jan 30 2026 03:48:56 &nbsp; <img border=0 src="favicon.png">
</small></address>
