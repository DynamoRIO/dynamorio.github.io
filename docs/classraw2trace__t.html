---
title: "raw2trace_t Class Reference"
layout: default
permalink: /classraw2trace__t.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">raw2trace_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;raw2trace.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae88903e56d49c6118d9bd34874794b6b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#ae88903e56d49c6118d9bd34874794b6b">handle_custom_data</a> (const char *(*parse_cb)(const char *src, OUT void **data), std::string(*process_cb)(<a class="el" href="group__drcovlib.html#ga70dd4ae0fcab1e7c8c090977eeeefa02">drmodtrack_info_t</a> *info, void *data, void *user_data), void *process_cb_user_data, void(*free_cb)(void *data))</td></tr>
<tr class="separator:ae88903e56d49c6118d9bd34874794b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2476351d49c4ec1902d77fccde436de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#ac2476351d49c4ec1902d77fccde436de">do_module_parsing</a> ()</td></tr>
<tr class="separator:ac2476351d49c4ec1902d77fccde436de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b63b0e61660418a5c1e985a64e952b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a3b63b0e61660418a5c1e985a64e952b4">do_module_parsing_and_mapping</a> ()</td></tr>
<tr class="separator:a3b63b0e61660418a5c1e985a64e952b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaa1498d372dafc8cd6efef5e6738ab"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#addaa1498d372dafc8cd6efef5e6738ab">find_mapped_trace_address</a> (app_pc trace_address, OUT app_pc *mapped_address)</td></tr>
<tr class="separator:addaa1498d372dafc8cd6efef5e6738ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6b5d0b31b6f5a759b648c14686da34"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#acf6b5d0b31b6f5a759b648c14686da34">do_conversion</a> ()</td></tr>
<tr class="separator:acf6b5d0b31b6f5a759b648c14686da34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8091d0412bba0843cf37c37df2bd8ecf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a8091d0412bba0843cf37c37df2bd8ecf">process_offline_entry</a> (raw2trace_thread_data_t *tdata, const offline_entry_t *in_entry, thread_id_t tid, OUT bool *end_of_record, OUT bool *last_bb_handled)</td></tr>
<tr class="separator:a8091d0412bba0843cf37c37df2bd8ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e8816df0d4ff4810ffb9c73626c8b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#ad94e8816df0d4ff4810ffb9c73626c8b">read_header</a> (raw2trace_thread_data_t *tdata, OUT <a class="el" href="structtrace__header__t.html">trace_header_t</a> *header)</td></tr>
<tr class="separator:ad94e8816df0d4ff4810ffb9c73626c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c45b0ed8eec451608b44f0da51d73c"><td class="memItemLeft" align="right" valign="top">virtual const offline_entry_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a58c45b0ed8eec451608b44f0da51d73c">get_next_entry</a> (raw2trace_thread_data_t *tdata)</td></tr>
<tr class="separator:a58c45b0ed8eec451608b44f0da51d73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2749e51648f1a921b8a09e4c80db768f"><td class="memItemLeft" align="right" valign="top">virtual const offline_entry_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a2749e51648f1a921b8a09e4c80db768f">get_next_entry_keep_prior</a> (raw2trace_thread_data_t *tdata)</td></tr>
<tr class="separator:a2749e51648f1a921b8a09e4c80db768f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401fd2c07107fa1ac8ada05e91789566"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a401fd2c07107fa1ac8ada05e91789566">on_thread_end</a> (raw2trace_thread_data_t *tdata)</td></tr>
<tr class="separator:a401fd2c07107fa1ac8ada05e91789566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd8fd92763df0d09dfb075f37b6d2c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a5fd8fd92763df0d09dfb075f37b6d2c2">log</a> (uint level, const char *fmt,...)</td></tr>
<tr class="separator:a5fd8fd92763df0d09dfb075f37b6d2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098b9db2b4f8ee58388e6bbaaa837911"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a098b9db2b4f8ee58388e6bbaaa837911">log_instruction</a> (uint level, app_pc decode_pc, app_pc orig_pc)</td></tr>
<tr class="separator:a098b9db2b4f8ee58388e6bbaaa837911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2396d4898db71ea879cedd78514dbb1e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a2396d4898db71ea879cedd78514dbb1e">process_next_thread_buffer</a> (raw2trace_thread_data_t *tdata, OUT bool *end_of_record)</td></tr>
<tr class="separator:a2396d4898db71ea879cedd78514dbb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09b55026d4567b4a5a97e84522064f5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; module_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#ac09b55026d4567b4a5a97e84522064f5">modvec_</a> () const</td></tr>
<tr class="separator:ac09b55026d4567b4a5a97e84522064f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84432fef0e925e3e96a060f7b4d9a90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a84432fef0e925e3e96a060f7b4d9a90f">set_modvec_</a> (const std::vector&lt; module_t &gt; *modvec)</td></tr>
<tr class="separator:a84432fef0e925e3e96a060f7b4d9a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9c4909895ac658b6838b94e4c1fbf4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmodule__mapper__t.html">module_mapper_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a3d9c4909895ac658b6838b94e4c1fbf4">modmap_</a> () const</td></tr>
<tr class="separator:a3d9c4909895ac658b6838b94e4c1fbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9377b2919c742af615fe92712f77ff8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a9377b2919c742af615fe92712f77ff8a">set_modmap_</a> (const <a class="el" href="classmodule__mapper__t.html">module_mapper_t</a> *modmap)</td></tr>
<tr class="separator:a9377b2919c742af615fe92712f77ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af8d74cdbcb4f75e60088b8834cd32094"><td class="memItemLeft" align="right" valign="top">void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#af8d74cdbcb4f75e60088b8834cd32094">dcontext_</a></td></tr>
<tr class="separator:af8d74cdbcb4f75e60088b8834cd32094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5626b3469f4b744ba215e326024c6639"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#a5626b3469f4b744ba215e326024c6639">passed_dcontext_</a> = false</td></tr>
<tr class="separator:a5626b3469f4b744ba215e326024c6639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ae7fbeacba22c5be4a305e8064d3e443f"><td class="memItemLeft" align="right" valign="top">static const uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classraw2trace__t.html#ae7fbeacba22c5be4a305e8064d3e443f">WRITE_BUFFER_SIZE</a> = 64</td></tr>
<tr class="separator:ae7fbeacba22c5be4a305e8064d3e443f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The raw2trace class converts the raw offline trace format to the format expected by analysis tools. It requires access to the binary files for the libraries and executable that were present during tracing. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acf6b5d0b31b6f5a759b648c14686da34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6b5d0b31b6f5a759b648c14686da34">&#9670;&nbsp;</a></span>do_conversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string raw2trace_t::do_conversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the conversion from raw data to finished trace files. Returns a non-empty error message on failure. </p>

</div>
</div>
<a id="ac2476351d49c4ec1902d77fccde436de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2476351d49c4ec1902d77fccde436de">&#9670;&nbsp;</a></span>do_module_parsing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string raw2trace_t::do_module_parsing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the first step of <a class="el" href="classraw2trace__t.html#acf6b5d0b31b6f5a759b648c14686da34">do_conversion()</a> without further action: parses and iterates over the list of modules. This is provided to give the user a method for iterating modules in the presence of the custom field used by drmemtrace that prevents direct use of <a class="el" href="group__drcovlib.html#ga56c631d77cd329a831116424204a2011">drmodtrack_offline_read()</a>. On success, calls the <code>process_cb</code> function passed to <a class="el" href="classraw2trace__t.html#ae88903e56d49c6118d9bd34874794b6b">handle_custom_data()</a> for every module in the list, and returns an empty string at the end. Returns a non-empty error message on failure.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd><a class="el" href="classmodule__mapper__t.html">module_mapper_t</a> should be used instead. </dd></dl>

</div>
</div>
<a id="a3b63b0e61660418a5c1e985a64e952b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b63b0e61660418a5c1e985a64e952b4">&#9670;&nbsp;</a></span>do_module_parsing_and_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string raw2trace_t::do_module_parsing_and_mapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This interface is meant to be used with a final trace rather than a raw trace, using the module log file saved from the raw2trace conversion. This routine first calls <a class="el" href="classraw2trace__t.html#ac2476351d49c4ec1902d77fccde436de">do_module_parsing()</a> and then maps each module into the current address space, allowing the user to augment the instruction information in the trace with additional information by decoding the instruction bytes. The routine <a class="el" href="classraw2trace__t.html#addaa1498d372dafc8cd6efef5e6738ab">find_mapped_trace_address()</a> should be used to convert from memref_t.instr.addr to the corresponding mapped address in the current process. Returns a non-empty error message on failure.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd><a class="el" href="classmodule__mapper__t.html#a1cc0d9c7f1afc3316b0c7edbc6325178">module_mapper_t::get_loaded_modules()</a> should be used instead. </dd></dl>

</div>
</div>
<a id="addaa1498d372dafc8cd6efef5e6738ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaa1498d372dafc8cd6efef5e6738ab">&#9670;&nbsp;</a></span>find_mapped_trace_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string raw2trace_t::find_mapped_trace_address </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>trace_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&#160;</td>
          <td class="paramname"><em>mapped_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This interface is meant to be used with a final trace rather than a raw trace, using the module log file saved from the raw2trace conversion. When <a class="el" href="classraw2trace__t.html#a3b63b0e61660418a5c1e985a64e952b4">do_module_parsing_and_mapping()</a> has been called, this routine can be used to convert an instruction program counter in a trace into an address in the current process where the instruction bytes for that instruction are mapped, allowing decoding for obtaining further information than is stored in the trace. Returns a non-empty error message on failure.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd><a class="el" href="classmodule__mapper__t.html#add0cc122b72c75d519971cde9eeffd87">module_mapper_t::find_mapped_trace_address()</a> should be used instead. </dd></dl>

</div>
</div>
<a id="a58c45b0ed8eec451608b44f0da51d73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c45b0ed8eec451608b44f0da51d73c">&#9670;&nbsp;</a></span>get_next_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const offline_entry_t* raw2trace_t::get_next_entry </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Point to the next offline entry_t. Will not attempt to dereference past the returned pointer. </p>

</div>
</div>
<a id="a2749e51648f1a921b8a09e4c80db768f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2749e51648f1a921b8a09e4c80db768f">&#9670;&nbsp;</a></span>get_next_entry_keep_prior()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const offline_entry_t* raw2trace_t::get_next_entry_keep_prior </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Records the currently stored last entry in order to remember two entries at once (for handling split two-entry markers) and then reads and returns a pointer to the next entry. A subsequent call to unread_last_entry() will put back both entries. Returns an emptry string on success or an error description on an error. </p>

</div>
</div>
<a id="ae88903e56d49c6118d9bd34874794b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88903e56d49c6118d9bd34874794b6b">&#9670;&nbsp;</a></span>handle_custom_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string raw2trace_t::handle_custom_data </td>
          <td>(</td>
          <td class="paramtype">const char *(*)(const char *src, OUT void **data)&#160;</td>
          <td class="paramname"><em>parse_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string(*)(<a class="el" href="group__drcovlib.html#ga70dd4ae0fcab1e7c8c090977eeeefa02">drmodtrack_info_t</a> *info, void *data, void *user_data)&#160;</td>
          <td class="paramname"><em>process_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>process_cb_user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *data)&#160;</td>
          <td class="paramname"><em>free_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds handling for custom data fields that were stored with each module via <a class="el" href="drmemtrace_8h.html#a8644981035cdedfafb000d03cd223399">drmemtrace_custom_module_data()</a> during trace generation. When <a class="el" href="classraw2trace__t.html#acf6b5d0b31b6f5a759b648c14686da34">do_conversion()</a> or <a class="el" href="classraw2trace__t.html#ac2476351d49c4ec1902d77fccde436de">do_module_parsing()</a> is subsequently called, its parsing of the module data will invoke <code>parse_cb</code>, which should advance the module data pointer passed in <code>src</code> and return it as its return value (or nullptr on error), returning the resulting parsed data in <code>data</code>. The <code>data</code> pointer will later be passed to both <code>process_cb</code>, which can update the module path inside <code>info</code> (and return a non-empty string on error), and <b>free_cb</b>, which can perform cleanup.</p>
<p>A custom callback value <code>process_cb_user_data</code> can be passed to <code>process_cb</code>. The same is not provided for the other callbacks as they end up using the <a class="el" href="group__drcovlib.html#ga9c2889006a80254645521f81a1a486f5">drmodtrack_add_custom_data()</a> framework where there is no support for custom callback parameters.</p>
<p>Returns a non-empty error message on failure. </p>

</div>
</div>
<a id="a5fd8fd92763df0d09dfb075f37b6d2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd8fd92763df0d09dfb075f37b6d2c2">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void raw2trace_t::log </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The level parameter represents severity: the lower the level, the higher the severity. </p>

</div>
</div>
<a id="a098b9db2b4f8ee58388e6bbaaa837911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098b9db2b4f8ee58388e6bbaaa837911">&#9670;&nbsp;</a></span>log_instruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void raw2trace_t::log_instruction </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>decode_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>orig_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classraw2trace__t.html#a5fd8fd92763df0d09dfb075f37b6d2c2">log()</a> but this disassembles the given PC. </p>

</div>
</div>
<a id="a3d9c4909895ac658b6838b94e4c1fbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9c4909895ac658b6838b94e4c1fbf4">&#9670;&nbsp;</a></span>modmap_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmodule__mapper__t.html">module_mapper_t</a>&amp; raw2trace_t::modmap_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the module mapper. </p>

</div>
</div>
<a id="ac09b55026d4567b4a5a97e84522064f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09b55026d4567b4a5a97e84522064f5">&#9670;&nbsp;</a></span>modvec_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;module_t&gt;&amp; raw2trace_t::modvec_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the module map. </p>

</div>
</div>
<a id="a401fd2c07107fa1ac8ada05e91789566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401fd2c07107fa1ac8ada05e91789566">&#9670;&nbsp;</a></span>on_thread_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string raw2trace_t::on_thread_end </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback notifying the currently-processed thread has exited. Subclasses are expected to track record metadata themselves. APIs for extracting that metadata are exposed. </p>

</div>
</div>
<a id="a2396d4898db71ea879cedd78514dbb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2396d4898db71ea879cedd78514dbb1e">&#9670;&nbsp;</a></span>process_next_thread_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string raw2trace_t::process_next_thread_buffer </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>end_of_record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Processes a raw buffer which must be the next buffer in the desired (typically timestamp-sorted) order for its traced thread. For concurrent buffer processing, all buffers from any one traced thread must be processed by the same worker thread, both for correct ordering and correct synchronization. </p>

</div>
</div>
<a id="a8091d0412bba0843cf37c37df2bd8ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8091d0412bba0843cf37c37df2bd8ecf">&#9670;&nbsp;</a></span>process_offline_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string raw2trace_t::process_offline_entry </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const offline_entry_t *&#160;</td>
          <td class="paramname"><em>in_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_id_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>end_of_record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>last_bb_handled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert starting from in_entry, and reading more entries as required. Sets end_of_record to true if processing hit the end of a record. read_and_map_modules() must have been called by the implementation before calling this API. </p>

</div>
</div>
<a id="ad94e8816df0d4ff4810ffb9c73626c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e8816df0d4ff4810ffb9c73626c8b">&#9670;&nbsp;</a></span>read_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string raw2trace_t::read_header </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="structtrace__header__t.html">trace_header_t</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the header of a thread, by calling <a class="el" href="classraw2trace__t.html#a58c45b0ed8eec451608b44f0da51d73c">get_next_entry()</a> successively to populate the header values. The timestamp field is populated only for legacy traces. </p>

</div>
</div>
<a id="a9377b2919c742af615fe92712f77ff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9377b2919c742af615fe92712f77ff8a">&#9670;&nbsp;</a></span>set_modmap_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void raw2trace_t::set_modmap_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmodule__mapper__t.html">module_mapper_t</a> *&#160;</td>
          <td class="paramname"><em>modmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the module mapper. Must be called before <a class="el" href="classraw2trace__t.html#a8091d0412bba0843cf37c37df2bd8ecf">process_offline_entry()</a> is called. </p>

</div>
</div>
<a id="a84432fef0e925e3e96a060f7b4d9a90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84432fef0e925e3e96a060f7b4d9a90f">&#9670;&nbsp;</a></span>set_modvec_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void raw2trace_t::set_modvec_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; module_t &gt; *&#160;</td>
          <td class="paramname"><em>modvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the module map. Must be called before <a class="el" href="classraw2trace__t.html#a8091d0412bba0843cf37c37df2bd8ecf">process_offline_entry()</a> is called. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="af8d74cdbcb4f75e60088b8834cd32094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d74cdbcb4f75e60088b8834cd32094">&#9670;&nbsp;</a></span>dcontext_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* const raw2trace_t::dcontext_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer to the DR context. </p>

</div>
</div>
<a id="a5626b3469f4b744ba215e326024c6639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5626b3469f4b744ba215e326024c6639">&#9670;&nbsp;</a></span>passed_dcontext_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool raw2trace_t::passed_dcontext_ = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether a non-nullptr dcontext was passed to the constructor. </p>

</div>
</div>
<a id="ae7fbeacba22c5be4a305e8064d3e443f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fbeacba22c5be4a305e8064d3e443f">&#9670;&nbsp;</a></span>WRITE_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint raw2trace_t::WRITE_BUFFER_SIZE = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The trace_entry_t buffer returned by get_write_buffer() is assumed to be at least <a class="el" href="classraw2trace__t.html#ae7fbeacba22c5be4a305e8064d3e443f">WRITE_BUFFER_SIZE</a> large. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/dynamorio/dynamorio/build_release-64/clients/include/drmemtrace/<a class="el" href="raw2trace_8h.html">raw2trace.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.92.19468 --- Fri Apr 21 2023 03:13:49 &nbsp; <img border=0 src="favicon.png">
</small></address>
