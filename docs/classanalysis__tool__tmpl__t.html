---
title: "analysis_tool_tmpl_t&lt; RecordType &gt; Class Template Reference"
layout: default
permalink: /classanalysis__tool__tmpl__t.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">analysis_tool_tmpl_t&lt; RecordType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;analysis_tool.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f64a19d0a00cae73fcc9d3cdd4e6150"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a1f64a19d0a00cae73fcc9d3cdd4e6150">analysis_tool_tmpl_t</a> ()</td></tr>
<tr class="separator:a1f64a19d0a00cae73fcc9d3cdd4e6150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5b2ad073a0d3533670f821fe564470"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2a5b2ad073a0d3533670f821fe564470">initialize</a> ()</td></tr>
<tr class="separator:a2a5b2ad073a0d3533670f821fe564470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e5077e003c33c0791dd9d681546b3c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#af9e5077e003c33c0791dd9d681546b3c">initialize_stream</a> (<a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *serial_stream)</td></tr>
<tr class="separator:af9e5077e003c33c0791dd9d681546b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd1bfb84e9793f75f57e2ee173942c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a8dd1bfb84e9793f75f57e2ee173942c0">operator!</a> ()</td></tr>
<tr class="separator:a8dd1bfb84e9793f75f57e2ee173942c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee68fe7b8c1d3a69f95e9af87c7c032"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string</a> ()</td></tr>
<tr class="separator:abee68fe7b8c1d3a69f95e9af87c7c032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f10585ae44b476e23055868314e9ede"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a3f10585ae44b476e23055868314e9ede">process_memref</a> (const RecordType &amp;entry)=0</td></tr>
<tr class="separator:a3f10585ae44b476e23055868314e9ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cdd10557e22df6844f0bb93e44b868"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results</a> ()=0</td></tr>
<tr class="separator:a39cdd10557e22df6844f0bb93e44b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a9bfa73defd4e53a7b66a8d39d57dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a97a9bfa73defd4e53a7b66a8d39d57dd">generate_interval_snapshot</a> (uint64_t interval_id)</td></tr>
<tr class="separator:a97a9bfa73defd4e53a7b66a8d39d57dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957b868c1a976e067a583a3fcf431b6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots</a> (const std::vector&lt; const <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt; latest_shard_snapshots, uint64_t interval_end_timestamp)</td></tr>
<tr class="separator:a957b868c1a976e067a583a3fcf431b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea30f4050fd4d252466d3079db28e56a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#aea30f4050fd4d252466d3079db28e56a">print_interval_results</a> (const std::vector&lt; <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt; &amp;interval_snapshots)</td></tr>
<tr class="separator:aea30f4050fd4d252466d3079db28e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb26a7ba40d46e27d3559cccf493fe3f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#aeb26a7ba40d46e27d3559cccf493fe3f">release_interval_snapshot</a> (<a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *interval_snapshot)</td></tr>
<tr class="separator:aeb26a7ba40d46e27d3559cccf493fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776cc2ff239d49d12e7a7c3c6ea59643"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a776cc2ff239d49d12e7a7c3c6ea59643">parallel_shard_supported</a> ()</td></tr>
<tr class="separator:a776cc2ff239d49d12e7a7c3c6ea59643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8303a5fe30ec0ccb16953cef19529f"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2e8303a5fe30ec0ccb16953cef19529f">parallel_worker_init</a> (int worker_index)</td></tr>
<tr class="separator:a2e8303a5fe30ec0ccb16953cef19529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929b42258390614d03cf0575e394af87"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a929b42258390614d03cf0575e394af87">parallel_worker_exit</a> (void *worker_data)</td></tr>
<tr class="separator:a929b42258390614d03cf0575e394af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d08e429b81e5481af1898e4cde390d9"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a5d08e429b81e5481af1898e4cde390d9">parallel_shard_init</a> (int shard_index, void *worker_data)</td></tr>
<tr class="separator:a5d08e429b81e5481af1898e4cde390d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be5a1d59ff06ef788c1e3a80bde7259"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream</a> (int shard_index, void *worker_data, <a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *shard_stream)</td></tr>
<tr class="separator:a2be5a1d59ff06ef788c1e3a80bde7259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4a076cf4f12c5564d2ccee3f955156"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a5c4a076cf4f12c5564d2ccee3f955156">parallel_shard_exit</a> (void *shard_data)</td></tr>
<tr class="separator:a5c4a076cf4f12c5564d2ccee3f955156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eddfed706a733c748e04f9a99eb7787"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref</a> (void *shard_data, const RecordType &amp;entry)</td></tr>
<tr class="separator:a2eddfed706a733c748e04f9a99eb7787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad164e039d96bdbfedb53256b35985643"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#ad164e039d96bdbfedb53256b35985643">parallel_shard_error</a> (void *shard_data)</td></tr>
<tr class="separator:ad164e039d96bdbfedb53256b35985643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a33504b07af30bf4b2b34829972350"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a45a33504b07af30bf4b2b34829972350">generate_shard_interval_snapshot</a> (void *shard_data, uint64_t interval_id)</td></tr>
<tr class="separator:a45a33504b07af30bf4b2b34829972350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f64a19d0a00cae73fcc9d3cdd4e6150"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a1f64a19d0a00cae73fcc9d3cdd4e6150">analysis_tool_tmpl_t</a> ()</td></tr>
<tr class="separator:a1f64a19d0a00cae73fcc9d3cdd4e6150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5b2ad073a0d3533670f821fe564470"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2a5b2ad073a0d3533670f821fe564470">initialize</a> ()</td></tr>
<tr class="separator:a2a5b2ad073a0d3533670f821fe564470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e5077e003c33c0791dd9d681546b3c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#af9e5077e003c33c0791dd9d681546b3c">initialize_stream</a> (<a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *serial_stream)</td></tr>
<tr class="separator:af9e5077e003c33c0791dd9d681546b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd1bfb84e9793f75f57e2ee173942c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a8dd1bfb84e9793f75f57e2ee173942c0">operator!</a> ()</td></tr>
<tr class="separator:a8dd1bfb84e9793f75f57e2ee173942c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee68fe7b8c1d3a69f95e9af87c7c032"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string</a> ()</td></tr>
<tr class="separator:abee68fe7b8c1d3a69f95e9af87c7c032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f10585ae44b476e23055868314e9ede"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a3f10585ae44b476e23055868314e9ede">process_memref</a> (const RecordType &amp;entry)=0</td></tr>
<tr class="separator:a3f10585ae44b476e23055868314e9ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cdd10557e22df6844f0bb93e44b868"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results</a> ()=0</td></tr>
<tr class="separator:a39cdd10557e22df6844f0bb93e44b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a9bfa73defd4e53a7b66a8d39d57dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a97a9bfa73defd4e53a7b66a8d39d57dd">generate_interval_snapshot</a> (uint64_t interval_id)</td></tr>
<tr class="separator:a97a9bfa73defd4e53a7b66a8d39d57dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957b868c1a976e067a583a3fcf431b6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots</a> (const std::vector&lt; const <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt; latest_shard_snapshots, uint64_t interval_end_timestamp)</td></tr>
<tr class="separator:a957b868c1a976e067a583a3fcf431b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea30f4050fd4d252466d3079db28e56a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#aea30f4050fd4d252466d3079db28e56a">print_interval_results</a> (const std::vector&lt; <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt; &amp;interval_snapshots)</td></tr>
<tr class="separator:aea30f4050fd4d252466d3079db28e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb26a7ba40d46e27d3559cccf493fe3f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#aeb26a7ba40d46e27d3559cccf493fe3f">release_interval_snapshot</a> (<a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *interval_snapshot)</td></tr>
<tr class="separator:aeb26a7ba40d46e27d3559cccf493fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776cc2ff239d49d12e7a7c3c6ea59643"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a776cc2ff239d49d12e7a7c3c6ea59643">parallel_shard_supported</a> ()</td></tr>
<tr class="separator:a776cc2ff239d49d12e7a7c3c6ea59643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8303a5fe30ec0ccb16953cef19529f"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2e8303a5fe30ec0ccb16953cef19529f">parallel_worker_init</a> (int worker_index)</td></tr>
<tr class="separator:a2e8303a5fe30ec0ccb16953cef19529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929b42258390614d03cf0575e394af87"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a929b42258390614d03cf0575e394af87">parallel_worker_exit</a> (void *worker_data)</td></tr>
<tr class="separator:a929b42258390614d03cf0575e394af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d08e429b81e5481af1898e4cde390d9"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a5d08e429b81e5481af1898e4cde390d9">parallel_shard_init</a> (int shard_index, void *worker_data)</td></tr>
<tr class="separator:a5d08e429b81e5481af1898e4cde390d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be5a1d59ff06ef788c1e3a80bde7259"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream</a> (int shard_index, void *worker_data, <a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *shard_stream)</td></tr>
<tr class="separator:a2be5a1d59ff06ef788c1e3a80bde7259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4a076cf4f12c5564d2ccee3f955156"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a5c4a076cf4f12c5564d2ccee3f955156">parallel_shard_exit</a> (void *shard_data)</td></tr>
<tr class="separator:a5c4a076cf4f12c5564d2ccee3f955156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eddfed706a733c748e04f9a99eb7787"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref</a> (void *shard_data, const RecordType &amp;entry)</td></tr>
<tr class="separator:a2eddfed706a733c748e04f9a99eb7787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad164e039d96bdbfedb53256b35985643"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#ad164e039d96bdbfedb53256b35985643">parallel_shard_error</a> (void *shard_data)</td></tr>
<tr class="separator:ad164e039d96bdbfedb53256b35985643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a33504b07af30bf4b2b34829972350"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classanalysis__tool__tmpl__t.html#a45a33504b07af30bf4b2b34829972350">generate_shard_interval_snapshot</a> (void *shard_data, uint64_t interval_id)</td></tr>
<tr class="separator:a45a33504b07af30bf4b2b34829972350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename RecordType&gt;<br />
class analysis_tool_tmpl_t&lt; RecordType &gt;</h3>

<p>The base class for a tool that analyzes a trace. A new tool should subclass this class.</p>
<p>Concurrent processing of traces is supported by logically splitting a trace into "shards" which are each processed sequentially. The default shard is a traced application thread, but the tool interface can support other divisions. For tools that support concurrent processing of shards and do not need to see a single thread-interleaved merged trace, the interface functions with the parallel_ prefix should be implemented, and <a class="el" href="classanalysis__tool__tmpl__t.html#a776cc2ff239d49d12e7a7c3c6ea59643">parallel_shard_supported()</a> should return true. <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> will be invoked for each shard prior to invoking <a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref()</a> for any entry in that shard; the data structure returned from <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> will be passed to <a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref()</a> for each trace entry for that shard. The concurrency model used guarantees that all entries from any one shard are processed by the same single worker thread, so no synchronization is needed inside the parallel_ functions. A single worker thread invokes <a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results()</a> as well.</p>
<p>For serial operation, <a class="el" href="classanalysis__tool__tmpl__t.html#a3f10585ae44b476e23055868314e9ede">process_memref()</a>, operates on a trace entry in a single, sorted, interleaved stream of trace entries. In the default mode of operation, the <a class="el" href="build__release-64_2clients_2include_2drmemtrace_2analyzer_8h.html#a0192ffac332b73bc42d499287f6bb4ea">analyzer_t</a> class iterates over the trace and calls the <a class="el" href="classanalysis__tool__tmpl__t.html#a3f10585ae44b476e23055868314e9ede">process_memref()</a> function of each tool. An alternative mode is supported which exposes the iterator and allows a separate control infrastructure to be built. This alternative mode does not support parallel operation at this time.</p>
<p>Both parallel and serial operation can be supported by a tool, typically by having <a class="el" href="classanalysis__tool__tmpl__t.html#a3f10585ae44b476e23055868314e9ede">process_memref()</a> create data on a newly seen traced thread and invoking <a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref()</a> to do its work.</p>
<p>For both parallel and serial operation, the function <a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results()</a> should be overridden. It is called just once after processing all trace data and it should present the results of the analysis. For parallel operation, any desired aggregation across the whole trace should occur here as well, while shard-specific results can be presented in <a class="el" href="classanalysis__tool__tmpl__t.html#a5c4a076cf4f12c5564d2ccee3f955156">parallel_shard_exit()</a>.</p>
<p>RecordType is the type of entry that is analyzed by the tool. Currently, we support <a class="el" href="memref_8h.html#a5dc7702c7dece5c18bb576bf26d724b5">memref_t</a> and <a class="el" href="trace__entry_8h.html#a2293547fa61d1c86efe2f1255889fea1">trace_entry_t</a>. <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt;<a class="el" href="memref_8h.html#a5dc7702c7dece5c18bb576bf26d724b5">memref_t</a>&gt; is the primary type of analysis tool and is used for most purposes. analysis_tool_tmpl_tâ‰¤::trace_entry_t&gt; is used in special cases where an offline trace needs to be observed exactly as stored on disk, without hiding any internal entries.</p>
<p>Analysis tools can subclass either of the specialized <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt;<a class="el" href="memref_8h.html#a5dc7702c7dece5c18bb576bf26d724b5">memref_t</a>&gt; or <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt;<a class="el" href="trace__entry_8h.html#a2293547fa61d1c86efe2f1255889fea1">trace_entry_t</a>&gt;, or <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a> itself, as required. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f64a19d0a00cae73fcc9d3cdd4e6150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f64a19d0a00cae73fcc9d3cdd4e6150">&#9670;&nbsp;</a></span>analysis_tool_tmpl_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::<a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Errors encountered during the constructor will set the success flag, which should be queried via operator!. On an error, <a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string()</a> provides a descriptive error message. </p>

</div>
</div>
<a id="a1f64a19d0a00cae73fcc9d3cdd4e6150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f64a19d0a00cae73fcc9d3cdd4e6150">&#9670;&nbsp;</a></span>analysis_tool_tmpl_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::<a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Errors encountered during the constructor will set the success flag, which should be queried via operator!. On an error, <a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string()</a> provides a descriptive error message. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a957b868c1a976e067a583a3fcf431b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957b868c1a976e067a583a3fcf431b6f">&#9670;&nbsp;</a></span>combine_interval_snapshots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a>* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::combine_interval_snapshots </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt;&#160;</td>
          <td class="paramname"><em>latest_shard_snapshots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval_end_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked by the framework to combine the shard-local <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> objects pointed at by <code>latest_shard_snapshots</code>, to create the combined <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> for the whole-trace interval that ends at <code>interval_end_timestamp</code>. This is useful in the parallel mode of the analyzer, where each trace shard is processed in parallel. In this mode, the framework creates the <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> for each whole-trace interval, one by one. For each interval, it invokes <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> with the latest seen interval snapshots from each shard (in <code>latest_shard_snapshots</code>) as of the interval ending at <code>interval_end_timestamp</code>. <code>latest_shard_snapshots</code> will contain at least one non-null element, and at least one of them will have its <code>interval_state_snapshot_t::interval_end_timestamp</code> set to <code>interval_end_timestamp</code>. Tools must not return a nullptr. Tools must not modify the provided snapshots.</p>
<p><code>interval_end_timestamp</code> helps the tool to determine which of the provided <code>latest_shard_snapshots</code> are relevant to it.</p><ul>
<li>for cumulative metrics (e.g. total instructions till an interval), the tool may want to combine latest interval snapshots from all shards to get the accurate cumulative count.</li>
<li>for delta metrics (e.g. incremental instructions in an interval), the tool may want to combine interval snapshots from only the shards that were observed in the current interval (with <code>latest_shard_snapshots</code> [i]-&gt;interval_end_timestamp == <code>interval_end_timestamp</code>)</li>
<li>or if the tool mixes cumulative and delta metrics: some field-specific logic that combines the above two strategies. </li>
</ul>

</div>
</div>
<a id="a957b868c1a976e067a583a3fcf431b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957b868c1a976e067a583a3fcf431b6f">&#9670;&nbsp;</a></span>combine_interval_snapshots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a>* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::combine_interval_snapshots </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt;&#160;</td>
          <td class="paramname"><em>latest_shard_snapshots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval_end_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked by the framework to combine the shard-local <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> objects pointed at by <code>latest_shard_snapshots</code>, to create the combined <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> for the whole-trace interval that ends at <code>interval_end_timestamp</code>. This is useful in the parallel mode of the analyzer, where each trace shard is processed in parallel. In this mode, the framework creates the <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> for each whole-trace interval, one by one. For each interval, it invokes <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> with the latest seen interval snapshots from each shard (in <code>latest_shard_snapshots</code>) as of the interval ending at <code>interval_end_timestamp</code>. <code>latest_shard_snapshots</code> will contain at least one non-null element, and at least one of them will have its <code>interval_state_snapshot_t::interval_end_timestamp</code> set to <code>interval_end_timestamp</code>. Tools must not return a nullptr. Tools must not modify the provided snapshots.</p>
<p><code>interval_end_timestamp</code> helps the tool to determine which of the provided <code>latest_shard_snapshots</code> are relevant to it.</p><ul>
<li>for cumulative metrics (e.g. total instructions till an interval), the tool may want to combine latest interval snapshots from all shards to get the accurate cumulative count.</li>
<li>for delta metrics (e.g. incremental instructions in an interval), the tool may want to combine interval snapshots from only the shards that were observed in the current interval (with <code>latest_shard_snapshots</code> [i]-&gt;interval_end_timestamp == <code>interval_end_timestamp</code>)</li>
<li>or if the tool mixes cumulative and delta metrics: some field-specific logic that combines the above two strategies. </li>
</ul>

</div>
</div>
<a id="a97a9bfa73defd4e53a7b66a8d39d57dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a9bfa73defd4e53a7b66a8d39d57dd">&#9670;&nbsp;</a></span>generate_interval_snapshot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a>* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::generate_interval_snapshot </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies the analysis tool that the given trace <code>interval_id</code> has ended so that it can generate a snapshot of its internal state in a struct derived from <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code>, and return a pointer to it. The returned pointer will be provided to the tool in later <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> and print_interval_result() calls.</p>
<p><code>interval_id</code> is a positive ordinal of the trace interval that just ended. Trace intervals have a length equal to the <code>-interval_microseconds</code> specified to the framework. Trace intervals are measured using the value of the <a class="el" href="trace__entry_8h.html#aa7f51b43d8f1e20dc45e3618684b15e9aab2a51d7215cf0da83ec1d74f980e89f">TRACE_MARKER_TYPE_TIMESTAMP</a> markers. The provided <code>interval_id</code> values will be monotonically increasing but may not be continuous, i.e. the tool may not see some <code>interval_id</code> if the trace did not have any activity in that interval.</p>
<p>The returned <code>interval_state_snapshot_t*</code> will be passed to the <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> API which is invoked by the framework to merge multiple <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> from different shards in the parallel mode of the analyzer.</p>
<p>Finally, the print_interval_result() API is invoked with a list of <code>interval_state_snapshot_t*</code> representing interval snapshots for the whole trace.</p>
<p>The tool must not de-allocate the state snapshot until <a class="el" href="classanalysis__tool__tmpl__t.html#aeb26a7ba40d46e27d3559cccf493fe3f">release_interval_snapshot()</a> is invoked by the framework.</p>
<p>An example use case of this API is to create a time series of some output metric over the whole trace. </p>

</div>
</div>
<a id="a97a9bfa73defd4e53a7b66a8d39d57dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a9bfa73defd4e53a7b66a8d39d57dd">&#9670;&nbsp;</a></span>generate_interval_snapshot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a>* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::generate_interval_snapshot </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies the analysis tool that the given trace <code>interval_id</code> has ended so that it can generate a snapshot of its internal state in a struct derived from <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code>, and return a pointer to it. The returned pointer will be provided to the tool in later <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> and print_interval_result() calls.</p>
<p><code>interval_id</code> is a positive ordinal of the trace interval that just ended. Trace intervals have a length equal to the <code>-interval_microseconds</code> specified to the framework. Trace intervals are measured using the value of the <a class="el" href="trace__entry_8h.html#aa7f51b43d8f1e20dc45e3618684b15e9aab2a51d7215cf0da83ec1d74f980e89f">TRACE_MARKER_TYPE_TIMESTAMP</a> markers. The provided <code>interval_id</code> values will be monotonically increasing but may not be continuous, i.e. the tool may not see some <code>interval_id</code> if the trace did not have any activity in that interval.</p>
<p>The returned <code>interval_state_snapshot_t*</code> will be passed to the <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> API which is invoked by the framework to merge multiple <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> from different shards in the parallel mode of the analyzer.</p>
<p>Finally, the print_interval_result() API is invoked with a list of <code>interval_state_snapshot_t*</code> representing interval snapshots for the whole trace.</p>
<p>The tool must not de-allocate the state snapshot until <a class="el" href="classanalysis__tool__tmpl__t.html#aeb26a7ba40d46e27d3559cccf493fe3f">release_interval_snapshot()</a> is invoked by the framework.</p>
<p>An example use case of this API is to create a time series of some output metric over the whole trace. </p>

</div>
</div>
<a id="a45a33504b07af30bf4b2b34829972350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a33504b07af30bf4b2b34829972350">&#9670;&nbsp;</a></span>generate_shard_interval_snapshot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a>* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::generate_shard_interval_snapshot </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies the analysis tool that the given trace <code>interval_id</code> in the shard represented by the given <code>shard_data</code> has ended, so that it can generate a snapshot of its internal state in a struct derived from <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code>, and return a pointer to it. The returned pointer will be provided to the tool in later <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> and print_interval_result() calls.</p>
<p>Note that the provided <code>interval_id</code> is local to the shard that is represented by the given <code>shard_data</code>, and not the whole-trace interval. The framework will automatically create an <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> for each whole-trace interval by using <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> to combine one or more shard-local <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> corresponding to that whole-trace interval.</p>
<p><code>interval_id</code> is a positive ordinal of the trace interval that just ended. Trace intervals have a length equal to the <code>-interval_microseconds</code> specified to the framework. Trace intervals are measured using the value of the <a class="el" href="trace__entry_8h.html#aa7f51b43d8f1e20dc45e3618684b15e9aab2a51d7215cf0da83ec1d74f980e89f">TRACE_MARKER_TYPE_TIMESTAMP</a> markers. The provided <code>interval_id</code> values will be monotonically increasing but may not be continuous, i.e. the tool may not see some <code>interval_id</code> if the trace shard did not have any activity in that interval.</p>
<p>The returned <code>interval_state_snapshot_t*</code> will be passed to the combine_interval_snapshot() API which is invoked by the framework to merge multiple <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> from different shards in the parallel mode of the analyzer.</p>
<p>Finally, the print_interval_result() API is invoked with a list of <code>interval_state_snapshot_t*</code> representing interval snapshots for the whole trace. In the parallel mode of the analyzer, this list is computed by combining the shard-local <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> using the tool's combine_interval_snapshot() API.</p>
<p>The tool must not de-allocate the state snapshot until <a class="el" href="classanalysis__tool__tmpl__t.html#aeb26a7ba40d46e27d3559cccf493fe3f">release_interval_snapshot()</a> is invoked by the framework.</p>
<p>An example use case of this API is to create a time series of some output metric over the whole trace. </p>

</div>
</div>
<a id="a45a33504b07af30bf4b2b34829972350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a33504b07af30bf4b2b34829972350">&#9670;&nbsp;</a></span>generate_shard_interval_snapshot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a>* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::generate_shard_interval_snapshot </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies the analysis tool that the given trace <code>interval_id</code> in the shard represented by the given <code>shard_data</code> has ended, so that it can generate a snapshot of its internal state in a struct derived from <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code>, and return a pointer to it. The returned pointer will be provided to the tool in later <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> and print_interval_result() calls.</p>
<p>Note that the provided <code>interval_id</code> is local to the shard that is represented by the given <code>shard_data</code>, and not the whole-trace interval. The framework will automatically create an <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> for each whole-trace interval by using <a class="el" href="classanalysis__tool__tmpl__t.html#a957b868c1a976e067a583a3fcf431b6f">combine_interval_snapshots()</a> to combine one or more shard-local <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> corresponding to that whole-trace interval.</p>
<p><code>interval_id</code> is a positive ordinal of the trace interval that just ended. Trace intervals have a length equal to the <code>-interval_microseconds</code> specified to the framework. Trace intervals are measured using the value of the <a class="el" href="trace__entry_8h.html#aa7f51b43d8f1e20dc45e3618684b15e9aab2a51d7215cf0da83ec1d74f980e89f">TRACE_MARKER_TYPE_TIMESTAMP</a> markers. The provided <code>interval_id</code> values will be monotonically increasing but may not be continuous, i.e. the tool may not see some <code>interval_id</code> if the trace shard did not have any activity in that interval.</p>
<p>The returned <code>interval_state_snapshot_t*</code> will be passed to the combine_interval_snapshot() API which is invoked by the framework to merge multiple <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> from different shards in the parallel mode of the analyzer.</p>
<p>Finally, the print_interval_result() API is invoked with a list of <code>interval_state_snapshot_t*</code> representing interval snapshots for the whole trace. In the parallel mode of the analyzer, this list is computed by combining the shard-local <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> using the tool's combine_interval_snapshot() API.</p>
<p>The tool must not de-allocate the state snapshot until <a class="el" href="classanalysis__tool__tmpl__t.html#aeb26a7ba40d46e27d3559cccf493fe3f">release_interval_snapshot()</a> is invoked by the framework.</p>
<p>An example use case of this API is to create a time series of some output metric over the whole trace. </p>

</div>
</div>
<a id="abee68fe7b8c1d3a69f95e9af87c7c032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee68fe7b8c1d3a69f95e9af87c7c032">&#9670;&nbsp;</a></span>get_error_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::get_error_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a description of the last error. </p>

</div>
</div>
<a id="abee68fe7b8c1d3a69f95e9af87c7c032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee68fe7b8c1d3a69f95e9af87c7c032">&#9670;&nbsp;</a></span>get_error_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::get_error_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a description of the last error. </p>

</div>
</div>
<a id="a2a5b2ad073a0d3533670f821fe564470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5b2ad073a0d3533670f821fe564470">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>The <a class="el" href="classanalysis__tool__tmpl__t.html#af9e5077e003c33c0791dd9d681546b3c">initialize_stream()</a> function is called by the analyzer; this function is only called if the default implementation of <a class="el" href="classanalysis__tool__tmpl__t.html#af9e5077e003c33c0791dd9d681546b3c">initialize_stream()</a> is left in place and it calls this version. On an error, this returns an error string. On success, it returns "". </dd></dl>

</div>
</div>
<a id="a2a5b2ad073a0d3533670f821fe564470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5b2ad073a0d3533670f821fe564470">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>The <a class="el" href="classanalysis__tool__tmpl__t.html#af9e5077e003c33c0791dd9d681546b3c">initialize_stream()</a> function is called by the analyzer; this function is only called if the default implementation of <a class="el" href="classanalysis__tool__tmpl__t.html#af9e5077e003c33c0791dd9d681546b3c">initialize_stream()</a> is left in place and it calls this version. On an error, this returns an error string. On success, it returns "". </dd></dl>

</div>
</div>
<a id="af9e5077e003c33c0791dd9d681546b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e5077e003c33c0791dd9d681546b3c">&#9670;&nbsp;</a></span>initialize_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::initialize_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *&#160;</td>
          <td class="paramname"><em>serial_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tools are encouraged to perform any initialization that might fail here rather than in the constructor. The <code>serial_stream</code> interface allows tools to query details of the underlying trace during serial operation; it is nullptr for parallel operation (a per-shard version is passed to <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a>). On an error, this returns an error string. On success, it returns "". </p>

</div>
</div>
<a id="af9e5077e003c33c0791dd9d681546b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e5077e003c33c0791dd9d681546b3c">&#9670;&nbsp;</a></span>initialize_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::initialize_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *&#160;</td>
          <td class="paramname"><em>serial_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tools are encouraged to perform any initialization that might fail here rather than in the constructor. The <code>serial_stream</code> interface allows tools to query details of the underlying trace during serial operation; it is nullptr for parallel operation (a per-shard version is passed to <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a>). On an error, this returns an error string. On success, it returns "". </p>

</div>
</div>
<a id="a8dd1bfb84e9793f75f57e2ee173942c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd1bfb84e9793f75f57e2ee173942c0">&#9670;&nbsp;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the tool was created successfully. </p>

</div>
</div>
<a id="a8dd1bfb84e9793f75f57e2ee173942c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd1bfb84e9793f75f57e2ee173942c0">&#9670;&nbsp;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the tool was created successfully. </p>

</div>
</div>
<a id="ad164e039d96bdbfedb53256b35985643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad164e039d96bdbfedb53256b35985643">&#9670;&nbsp;</a></span>parallel_shard_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_error </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a description of the last error for this shard. </p>

</div>
</div>
<a id="ad164e039d96bdbfedb53256b35985643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad164e039d96bdbfedb53256b35985643">&#9670;&nbsp;</a></span>parallel_shard_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_error </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a description of the last error for this shard. </p>

</div>
</div>
<a id="a5c4a076cf4f12c5564d2ccee3f955156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4a076cf4f12c5564d2ccee3f955156">&#9670;&nbsp;</a></span>parallel_shard_exit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once when all trace entries for a shard have been processed. <code>shard_data</code> is the value returned by <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> for this shard. This allows a tool to clean up its thread data, or to report thread analysis results. Most tools, however, prefer to aggregate data or at least sort data, and perform nothing here, doing all cleanup in <a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results()</a> by storing the thread data into a table. Return whether exiting was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#ad164e039d96bdbfedb53256b35985643">parallel_shard_error()</a> returns a descriptive message. </p>

</div>
</div>
<a id="a5c4a076cf4f12c5564d2ccee3f955156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4a076cf4f12c5564d2ccee3f955156">&#9670;&nbsp;</a></span>parallel_shard_exit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once when all trace entries for a shard have been processed. <code>shard_data</code> is the value returned by <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> for this shard. This allows a tool to clean up its thread data, or to report thread analysis results. Most tools, however, prefer to aggregate data or at least sort data, and perform nothing here, doing all cleanup in <a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results()</a> by storing the thread data into a table. Return whether exiting was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#ad164e039d96bdbfedb53256b35985643">parallel_shard_error()</a> returns a descriptive message. </p>

</div>
</div>
<a id="a5d08e429b81e5481af1898e4cde390d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d08e429b81e5481af1898e4cde390d9">&#9670;&nbsp;</a></span>parallel_shard_init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shard_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>worker_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>The <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> is what is called by the analyzer; this function is only called if the default implementation of <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> is left in place and it calls this version. </dd></dl>

</div>
</div>
<a id="a5d08e429b81e5481af1898e4cde390d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d08e429b81e5481af1898e4cde390d9">&#9670;&nbsp;</a></span>parallel_shard_init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shard_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>worker_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>The <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> is what is called by the analyzer; this function is only called if the default implementation of <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> is left in place and it calls this version. </dd></dl>

</div>
</div>
<a id="a2be5a1d59ff06ef788c1e3a80bde7259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be5a1d59ff06ef788c1e3a80bde7259">&#9670;&nbsp;</a></span>parallel_shard_init_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_init_stream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shard_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>worker_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *&#160;</td>
          <td class="paramname"><em>shard_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once for each trace shard prior to calling <a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref()</a> for that shard, this allows a tool to create data local to a shard. The <code>shard_index</code> is a unique identifier allowing shard data to be stored into a global table if desired (typically for aggregation use in <a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results()</a>). The <code>worker_data</code> is the return value of <a class="el" href="classanalysis__tool__tmpl__t.html#a2e8303a5fe30ec0ccb16953cef19529f">parallel_worker_init()</a> for the worker thread who will exclusively operate on this shard. The <code>shard_stream</code> allows tools to query details of the underlying trace shard during parallel operation; it is valid only until <a class="el" href="classanalysis__tool__tmpl__t.html#a5c4a076cf4f12c5564d2ccee3f955156">parallel_shard_exit()</a> is called. The return value here will be passed to each invocation of <a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref()</a> for that same shard. </p>

</div>
</div>
<a id="a2be5a1d59ff06ef788c1e3a80bde7259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be5a1d59ff06ef788c1e3a80bde7259">&#9670;&nbsp;</a></span>parallel_shard_init_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_init_stream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shard_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>worker_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmemtrace__stream__t.html">memtrace_stream_t</a> *&#160;</td>
          <td class="paramname"><em>shard_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once for each trace shard prior to calling <a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref()</a> for that shard, this allows a tool to create data local to a shard. The <code>shard_index</code> is a unique identifier allowing shard data to be stored into a global table if desired (typically for aggregation use in <a class="el" href="classanalysis__tool__tmpl__t.html#a39cdd10557e22df6844f0bb93e44b868">print_results()</a>). The <code>worker_data</code> is the return value of <a class="el" href="classanalysis__tool__tmpl__t.html#a2e8303a5fe30ec0ccb16953cef19529f">parallel_worker_init()</a> for the worker thread who will exclusively operate on this shard. The <code>shard_stream</code> allows tools to query details of the underlying trace shard during parallel operation; it is valid only until <a class="el" href="classanalysis__tool__tmpl__t.html#a5c4a076cf4f12c5564d2ccee3f955156">parallel_shard_exit()</a> is called. The return value here will be passed to each invocation of <a class="el" href="classanalysis__tool__tmpl__t.html#a2eddfed706a733c748e04f9a99eb7787">parallel_shard_memref()</a> for that same shard. </p>

</div>
</div>
<a id="a2eddfed706a733c748e04f9a99eb7787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eddfed706a733c748e04f9a99eb7787">&#9670;&nbsp;</a></span>parallel_shard_memref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_memref </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordType &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The heart of an analysis tool, this routine operates on a single trace entry and takes whatever actions the tool needs to perform its analysis. The <code>shard_data</code> parameter is the value returned by <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> for this shard. Since each shard is operated upon in its entirety by the same worker thread, no synchronization is needed. The return value indicates whether this function was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#ad164e039d96bdbfedb53256b35985643">parallel_shard_error()</a> returns a descriptive message. </p>

</div>
</div>
<a id="a2eddfed706a733c748e04f9a99eb7787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eddfed706a733c748e04f9a99eb7787">&#9670;&nbsp;</a></span>parallel_shard_memref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_memref </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>shard_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordType &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The heart of an analysis tool, this routine operates on a single trace entry and takes whatever actions the tool needs to perform its analysis. The <code>shard_data</code> parameter is the value returned by <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> for this shard. Since each shard is operated upon in its entirety by the same worker thread, no synchronization is needed. The return value indicates whether this function was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#ad164e039d96bdbfedb53256b35985643">parallel_shard_error()</a> returns a descriptive message. </p>

</div>
</div>
<a id="a776cc2ff239d49d12e7a7c3c6ea59643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776cc2ff239d49d12e7a7c3c6ea59643">&#9670;&nbsp;</a></span>parallel_shard_supported() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_supported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this tool supports analyzing trace shards concurrently, or whether it needs to see a single thread-interleaved stream of traced events. This may be called prior to <a class="el" href="classanalysis__tool__tmpl__t.html#a2a5b2ad073a0d3533670f821fe564470">initialize()</a>. </p>

</div>
</div>
<a id="a776cc2ff239d49d12e7a7c3c6ea59643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776cc2ff239d49d12e7a7c3c6ea59643">&#9670;&nbsp;</a></span>parallel_shard_supported() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_shard_supported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this tool supports analyzing trace shards concurrently, or whether it needs to see a single thread-interleaved stream of traced events. This may be called prior to <a class="el" href="classanalysis__tool__tmpl__t.html#a2a5b2ad073a0d3533670f821fe564470">initialize()</a>. </p>

</div>
</div>
<a id="a929b42258390614d03cf0575e394af87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929b42258390614d03cf0575e394af87">&#9670;&nbsp;</a></span>parallel_worker_exit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_worker_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>worker_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once when a worker thread is finished processing all shard data. The <code>worker_data</code> is the return value of <a class="el" href="classanalysis__tool__tmpl__t.html#a2e8303a5fe30ec0ccb16953cef19529f">parallel_worker_init()</a>. A non-empty string indicates an error while an empty string indicates success. </p>

</div>
</div>
<a id="a929b42258390614d03cf0575e394af87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929b42258390614d03cf0575e394af87">&#9670;&nbsp;</a></span>parallel_worker_exit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_worker_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>worker_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once when a worker thread is finished processing all shard data. The <code>worker_data</code> is the return value of <a class="el" href="classanalysis__tool__tmpl__t.html#a2e8303a5fe30ec0ccb16953cef19529f">parallel_worker_init()</a>. A non-empty string indicates an error while an empty string indicates success. </p>

</div>
</div>
<a id="a2e8303a5fe30ec0ccb16953cef19529f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8303a5fe30ec0ccb16953cef19529f">&#9670;&nbsp;</a></span>parallel_worker_init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_worker_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worker_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once for each worker thread prior to calling any shard routine from that thread. This allows a tool to create data local to a worker, such as a cache of data global to the trace that crosses shards. This data does not need any synchronization as it will only be accessed by this worker thread. The <code>worker_index</code> is a unique identifier for this worker. The return value here will be passed to the invocation of <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> for each shard upon which this worker operates. </p>

</div>
</div>
<a id="a2e8303a5fe30ec0ccb16953cef19529f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8303a5fe30ec0ccb16953cef19529f">&#9670;&nbsp;</a></span>parallel_worker_init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::parallel_worker_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worker_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked once for each worker thread prior to calling any shard routine from that thread. This allows a tool to create data local to a worker, such as a cache of data global to the trace that crosses shards. This data does not need any synchronization as it will only be accessed by this worker thread. The <code>worker_index</code> is a unique identifier for this worker. The return value here will be passed to the invocation of <a class="el" href="classanalysis__tool__tmpl__t.html#a2be5a1d59ff06ef788c1e3a80bde7259">parallel_shard_init_stream()</a> for each shard upon which this worker operates. </p>

</div>
</div>
<a id="aea30f4050fd4d252466d3079db28e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea30f4050fd4d252466d3079db28e56a">&#9670;&nbsp;</a></span>print_interval_results() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::print_interval_results </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval_snapshots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the interval results for the given series of interval state snapshots in <code>interval_snapshots</code>.</p>
<p>This is currently invoked with the list of whole-trace interval snapshots (for the parallel mode, these are the snapshots created by merging the shard-local snapshots).</p>
<p>The framework should be able to invoke this multiple times, possibly with a different list of interval snapshots. So it should avoid free-ing memory or changing global state. This is to keep open the possibility of the framework printing interval results for each shard separately in future. </p>

</div>
</div>
<a id="aea30f4050fd4d252466d3079db28e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea30f4050fd4d252466d3079db28e56a">&#9670;&nbsp;</a></span>print_interval_results() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::print_interval_results </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval_snapshots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the interval results for the given series of interval state snapshots in <code>interval_snapshots</code>.</p>
<p>This is currently invoked with the list of whole-trace interval snapshots (for the parallel mode, these are the snapshots created by merging the shard-local snapshots).</p>
<p>The framework should be able to invoke this multiple times, possibly with a different list of interval snapshots. So it should avoid free-ing memory or changing global state. This is to keep open the possibility of the framework printing interval results for each shard separately in future. </p>

</div>
</div>
<a id="a39cdd10557e22df6844f0bb93e44b868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cdd10557e22df6844f0bb93e44b868">&#9670;&nbsp;</a></span>print_results() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::print_results </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This routine reports the results of the trace analysis. It should leave the i/o state in a default format (std::dec) to support multiple tools. The return value indicates whether it was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string()</a> returns a descriptive message. </p>

</div>
</div>
<a id="a39cdd10557e22df6844f0bb93e44b868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cdd10557e22df6844f0bb93e44b868">&#9670;&nbsp;</a></span>print_results() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::print_results </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This routine reports the results of the trace analysis. It should leave the i/o state in a default format (std::dec) to support multiple tools. The return value indicates whether it was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string()</a> returns a descriptive message. </p>

</div>
</div>
<a id="a3f10585ae44b476e23055868314e9ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f10585ae44b476e23055868314e9ede">&#9670;&nbsp;</a></span>process_memref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::process_memref </td>
          <td>(</td>
          <td class="paramtype">const RecordType &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The heart of an analysis tool, this routine operates on a single trace entry and takes whatever actions the tool needs to perform its analysis. If it prints, it should leave the i/o state in a default format (std::dec) to support multiple tools. The return value indicates whether it was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string()</a> returns a descriptive message. </p>

</div>
</div>
<a id="a3f10585ae44b476e23055868314e9ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f10585ae44b476e23055868314e9ede">&#9670;&nbsp;</a></span>process_memref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::process_memref </td>
          <td>(</td>
          <td class="paramtype">const RecordType &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The heart of an analysis tool, this routine operates on a single trace entry and takes whatever actions the tool needs to perform its analysis. If it prints, it should leave the i/o state in a default format (std::dec) to support multiple tools. The return value indicates whether it was successful. On failure, <a class="el" href="classanalysis__tool__tmpl__t.html#abee68fe7b8c1d3a69f95e9af87c7c032">get_error_string()</a> returns a descriptive message. </p>

</div>
</div>
<a id="aeb26a7ba40d46e27d3559cccf493fe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb26a7ba40d46e27d3559cccf493fe3f">&#9670;&nbsp;</a></span>release_interval_snapshot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::release_interval_snapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td>
          <td class="paramname"><em>interval_snapshot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies the tool that the <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> object pointed to by <code>interval_snapshot</code> is no longer needed by the framework. The tool may de-allocate it right away or later, as it needs. Returns whether it was successful. </p>

</div>
</div>
<a id="aeb26a7ba40d46e27d3559cccf493fe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb26a7ba40d46e27d3559cccf493fe3f">&#9670;&nbsp;</a></span>release_interval_snapshot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classanalysis__tool__tmpl__t.html">analysis_tool_tmpl_t</a>&lt; RecordType &gt;::release_interval_snapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a> *&#160;</td>
          <td class="paramname"><em>interval_snapshot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies the tool that the <code><a class="el" href="structanalysis__tool__tmpl__t_1_1interval__state__snapshot__t.html">interval_state_snapshot_t</a></code> object pointed to by <code>interval_snapshot</code> is no longer needed by the framework. The tool may de-allocate it right away or later, as it needs. Returns whether it was successful. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/dynamorio/dynamorio/build_release-64/clients/include/drmemtrace/<a class="el" href="build__release-64_2clients_2include_2drmemtrace_2analysis__tool_8h.html">analysis_tool.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 9.93.19509 --- Fri Jun 2 2023 03:14:16 &nbsp; <img border=0 src="favicon.png">
</small></address>
