---
title: "dynamorio::drmemtrace::scheduler_tmpl_t&lt; RecordType, ReaderType &gt;::scheduler_options_t Struct Reference"
layout: default
permalink: /structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedynamorio.html">dynamorio</a></li><li class="navelem"><a class="el" href="namespacedynamorio_1_1drmemtrace.html">drmemtrace</a></li><li class="navelem"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">scheduler_tmpl_t</a></li><li class="navelem"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html">scheduler_options_t</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">dynamorio::drmemtrace::scheduler_tmpl_t&lt; RecordType, ReaderType &gt;::scheduler_options_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;scheduler.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2035bc9fd562905ac51f3dc72415fab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2035bc9fd562905ac51f3dc72415fab8">scheduler_options_t</a> ()</td></tr>
<tr class="separator:a2035bc9fd562905ac51f3dc72415fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52005dc3fe02a08f6aaf9ec1ca35cd4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a52005dc3fe02a08f6aaf9ec1ca35cd4a">scheduler_options_t</a> (<a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0cc">mapping_t</a> <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a86653e52217b6c9cf328696e911c4f57">mapping</a>, <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9">inter_input_dependency_t</a> <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a70309788c8288f6981dffb5bb9513920">deps</a>, <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8">scheduler_flags_t</a> <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0aaac9f5b93b10fa4c72b620312f1bcd">flags</a>=<a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8ad602678474ddeba790605499c3c01c24">SCHEDULER_DEFAULTS</a>, int <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#afbaa418768eead0d256ea889fda40fef">verbosity</a>=0)</td></tr>
<tr class="separator:a52005dc3fe02a08f6aaf9ec1ca35cd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a2b8c561839112c900eda07ec8171abfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2b8c561839112c900eda07ec8171abfb">struct_size</a> = sizeof(<a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html">scheduler_options_t</a>)</td></tr>
<tr class="separator:a2b8c561839112c900eda07ec8171abfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86653e52217b6c9cf328696e911c4f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0cc">mapping_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a86653e52217b6c9cf328696e911c4f57">mapping</a> = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0ccaba192b7d617035b922db1f3960154406">MAP_TO_ANY_OUTPUT</a></td></tr>
<tr class="separator:a86653e52217b6c9cf328696e911c4f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70309788c8288f6981dffb5bb9513920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9">inter_input_dependency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a70309788c8288f6981dffb5bb9513920">deps</a> = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9af3b4cadcd03eac1003ccd1aced5e2823">DEPENDENCY_IGNORE</a></td></tr>
<tr class="separator:a70309788c8288f6981dffb5bb9513920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaac9f5b93b10fa4c72b620312f1bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8">scheduler_flags_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0aaac9f5b93b10fa4c72b620312f1bcd">flags</a> = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8ad602678474ddeba790605499c3c01c24">SCHEDULER_DEFAULTS</a></td></tr>
<tr class="separator:a0aaac9f5b93b10fa4c72b620312f1bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c57c376cbbfab5749e673c2b54ff1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199">quantum_unit_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a9c57c376cbbfab5749e673c2b54ff1fb">quantum_unit</a> = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199a8e189556d69dfb51884cfe5c0bab5196">QUANTUM_INSTRUCTIONS</a></td></tr>
<tr class="separator:a9c57c376cbbfab5749e673c2b54ff1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab318281b3d416a47029f1e530f1bb472"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ab318281b3d416a47029f1e530f1bb472">quantum_duration</a> = 0</td></tr>
<tr class="separator:ab318281b3d416a47029f1e530f1bb472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaa418768eead0d256ea889fda40fef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#afbaa418768eead0d256ea889fda40fef">verbosity</a> = 0</td></tr>
<tr class="separator:afbaa418768eead0d256ea889fda40fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d951e6e51647de93dc52083157dab81"><td class="memItemLeft" align="right" valign="top">archive_ostream_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0d951e6e51647de93dc52083157dab81">schedule_record_ostream</a> = nullptr</td></tr>
<tr class="separator:a0d951e6e51647de93dc52083157dab81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd6e85c8a7b37a2cbdfc64efc60537e"><td class="memItemLeft" align="right" valign="top">archive_istream_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#aebd6e85c8a7b37a2cbdfc64efc60537e">schedule_replay_istream</a> = nullptr</td></tr>
<tr class="separator:aebd6e85c8a7b37a2cbdfc64efc60537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5367da0081dd5caed8d3d0c02fb9b6f2"><td class="memItemLeft" align="right" valign="top">archive_istream_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a5367da0081dd5caed8d3d0c02fb9b6f2">replay_as_traced_istream</a> = nullptr</td></tr>
<tr class="separator:a5367da0081dd5caed8d3d0c02fb9b6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea3487c8bbdb7ae52212b245c866608"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a6ea3487c8bbdb7ae52212b245c866608">syscall_switch_threshold</a> = 30000000</td></tr>
<tr class="separator:a6ea3487c8bbdb7ae52212b245c866608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea4a3f44bad298c9dffcc555f5d4241"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0ea4a3f44bad298c9dffcc555f5d4241">blocking_switch_threshold</a> = 500</td></tr>
<tr class="separator:a0ea4a3f44bad298c9dffcc555f5d4241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8933439fdf03dd72c3b849e1c4052c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a6c8933439fdf03dd72c3b849e1c4052c">block_time_scale</a> = 0.</td></tr>
<tr class="separator:a6c8933439fdf03dd72c3b849e1c4052c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94617954966af426181065a7edfa1f9b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a94617954966af426181065a7edfa1f9b">block_time_max</a> = 0</td></tr>
<tr class="separator:a94617954966af426181065a7edfa1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5665d877a7b54ed406752c2bf26cebea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a5665d877a7b54ed406752c2bf26cebea">kernel_switch_trace_path</a></td></tr>
<tr class="separator:a5665d877a7b54ed406752c2bf26cebea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e02a6e38c2872b6b0c0dc287772544c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ReaderType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a9e02a6e38c2872b6b0c0dc287772544c">kernel_switch_reader</a></td></tr>
<tr class="separator:a9e02a6e38c2872b6b0c0dc287772544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b1d12f5c6c169d92d12c045fe653a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ReaderType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ae6b1d12f5c6c169d92d12c045fe653a1">kernel_switch_reader_end</a></td></tr>
<tr class="separator:ae6b1d12f5c6c169d92d12c045fe653a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1783ff3a0ff0f81cb38922f8093a9118"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a1783ff3a0ff0f81cb38922f8093a9118">single_lockstep_output</a> = false</td></tr>
<tr class="separator:a1783ff3a0ff0f81cb38922f8093a9118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9eb1d470d20cf68c3fa76250b074fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a9b9eb1d470d20cf68c3fa76250b074fe">randomize_next_input</a> = false</td></tr>
<tr class="separator:a9b9eb1d470d20cf68c3fa76250b074fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eaff9f2887f3469d737f73ad093343"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a34eaff9f2887f3469d737f73ad093343">read_inputs_in_init</a> = true</td></tr>
<tr class="separator:a34eaff9f2887f3469d737f73ad093343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c2216050c0dd876a43990c44919ba9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a02c2216050c0dd876a43990c44919ba9">honor_direct_switches</a> = true</td></tr>
<tr class="separator:a02c2216050c0dd876a43990c44919ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57204006ea4057e5a53e21abdc4e5dc3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a> = 1000.</td></tr>
<tr class="separator:a57204006ea4057e5a53e21abdc4e5dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287db4eea35cf618e9dcd2d44b1e7e15"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a287db4eea35cf618e9dcd2d44b1e7e15">quantum_duration_us</a> = 5000</td></tr>
<tr class="separator:a287db4eea35cf618e9dcd2d44b1e7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893632f58364745f024b00365beef461"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a893632f58364745f024b00365beef461">quantum_duration_instrs</a> = 10 * 1000 * 1000</td></tr>
<tr class="separator:a893632f58364745f024b00365beef461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76efe32409f8e56731cf218c67cb28ef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a76efe32409f8e56731cf218c67cb28ef">block_time_multiplier</a> = 0.1</td></tr>
<tr class="separator:a76efe32409f8e56731cf218c67cb28ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bf45c6ae11854a847a1c5ff27c03a0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ad3bf45c6ae11854a847a1c5ff27c03a0">block_time_max_us</a> = 2500</td></tr>
<tr class="separator:ad3bf45c6ae11854a847a1c5ff27c03a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af201380524f570dd73c5e3803eca9ee4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#af201380524f570dd73c5e3803eca9ee4">migration_threshold_us</a> = 500</td></tr>
<tr class="separator:af201380524f570dd73c5e3803eca9ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94dd7429c3b333b663526268441d7a3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ab94dd7429c3b333b663526268441d7a3">rebalance_period_us</a> = 50000</td></tr>
<tr class="separator:ab94dd7429c3b333b663526268441d7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64ac5c9ce99ff13be8a80d287d9f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ace64ac5c9ce99ff13be8a80d287d9f46">honor_infinite_timeouts</a> = false</td></tr>
<tr class="separator:ace64ac5c9ce99ff13be8a80d287d9f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac627a524c333875673d4a1302e9ee2f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ac627a524c333875673d4a1302e9ee2f3">exit_if_fraction_inputs_left</a> = 0.1</td></tr>
<tr class="separator:ac627a524c333875673d4a1302e9ee2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffac2cf5ac00980653bbf22b31a51e4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#aeffac2cf5ac00980653bbf22b31a51e4">kernel_syscall_trace_path</a></td></tr>
<tr class="separator:aeffac2cf5ac00980653bbf22b31a51e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08d4779407ad848c57c49e12f668d3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ReaderType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0a08d4779407ad848c57c49e12f668d3">kernel_syscall_reader</a></td></tr>
<tr class="separator:a0a08d4779407ad848c57c49e12f668d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb03123ae868a8da8a499d664336b321"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ReaderType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#afb03123ae868a8da8a499d664336b321">kernel_syscall_reader_end</a></td></tr>
<tr class="separator:afb03123ae868a8da8a499d664336b321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename RecordType, typename ReaderType&gt;<br />
struct dynamorio::drmemtrace::scheduler_tmpl_t&lt; RecordType, ReaderType &gt;::scheduler_options_t</h3>

<p>Collects the parameters specifying how the scheduler should behave, outside of the workload inputs and the output count. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2035bc9fd562905ac51f3dc72415fab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2035bc9fd562905ac51f3dc72415fab8">&#9670;&nbsp;</a></span>scheduler_options_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::scheduler_options_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a default set of options. </p>

</div>
</div>
<a id="a52005dc3fe02a08f6aaf9ec1ca35cd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52005dc3fe02a08f6aaf9ec1ca35cd4a">&#9670;&nbsp;</a></span>scheduler_options_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::scheduler_options_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0cc">mapping_t</a>&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9">inter_input_dependency_t</a>&#160;</td>
          <td class="paramname"><em>deps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8">scheduler_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8ad602678474ddeba790605499c3c01c24">SCHEDULER_DEFAULTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a set of options with the given type and strategy. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a94617954966af426181065a7edfa1f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94617954966af426181065a7edfa1f9b">&#9670;&nbsp;</a></span>block_time_max</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::block_time_max = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated: use <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ad3bf45c6ae11854a847a1c5ff27c03a0">block_time_max_us</a> and <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a> instead. It is an error to set this to a non-zero value when <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2b8c561839112c900eda07ec8171abfb">struct_size</a> includes <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ad3bf45c6ae11854a847a1c5ff27c03a0">block_time_max_us</a>. When <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2b8c561839112c900eda07ec8171abfb">struct_size</a> does not include <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ad3bf45c6ae11854a847a1c5ff27c03a0">block_time_max_us</a> and this value is non-zero, the value in <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ad3bf45c6ae11854a847a1c5ff27c03a0">block_time_max_us</a> is replaced with this value divided by the default value of <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a>. </p>

</div>
</div>
<a id="ad3bf45c6ae11854a847a1c5ff27c03a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bf45c6ae11854a847a1c5ff27c03a0">&#9670;&nbsp;</a></span>block_time_max_us</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::block_time_max_us = 2500</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum time in microseconds for an input to be considered blocked for any one system call. This value is multiplied by <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a> to produce a value that is compared to the "cur_time" parameter to next_record(). If any block time (see <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a76efe32409f8e56731cf218c67cb28ef">block_time_multiplier</a>) exceeds this value, it is capped to this value. This value is also used as a fallback to avoid hangs when there are no scheduled inputs: if the only inputs left are "unscheduled" (see <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca6033baf3bb4bf61879c01e91e246b115">TRACE_MARKER_TYPE_SYSCALL_UNSCHEDULE</a>), after this amount of time those inputs are all re-scheduled. </p>

</div>
</div>
<a id="a76efe32409f8e56731cf218c67cb28ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76efe32409f8e56731cf218c67cb28ef">&#9670;&nbsp;</a></span>block_time_multiplier</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::block_time_multiplier = 0.1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the amount of time inputs are considered blocked at a syscall whose as-traced latency (recorded in timestamp records in the trace) exceeds <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a6ea3487c8bbdb7ae52212b245c866608">syscall_switch_threshold</a> or <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0ea4a3f44bad298c9dffcc555f5d4241">blocking_switch_threshold</a>. The as-traced syscall latency (which is in traced microseconds) is multiplied by this field to produce the blocked time in simulated microseconds. Once that many simulated microseconds have passed according to the "cur_time" value passed to next_record() (multiplied by <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a>), the input will be no longer considered blocked. The blocked time is clamped to a maximum value controlled by <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a94617954966af426181065a7edfa1f9b">block_time_max</a>.</p>
<p>While there is no direct overhead during tracing, indirect overhead does result in some inflation of recorded system call latencies. Thus, a value below 0 is typically used here. This value, in combination with <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ad3bf45c6ae11854a847a1c5ff27c03a0">block_time_max_us</a>, can be tuned to achieve a desired idle rate. The default value errs on the side of less idle time. </p>

</div>
</div>
<a id="a6c8933439fdf03dd72c3b849e1c4052c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8933439fdf03dd72c3b849e1c4052c">&#9670;&nbsp;</a></span>block_time_scale</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::block_time_scale = 0.</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated: use <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a76efe32409f8e56731cf218c67cb28ef">block_time_multiplier</a> instead. It is an error to set this to a non-zero value when <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2b8c561839112c900eda07ec8171abfb">struct_size</a> includes <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a76efe32409f8e56731cf218c67cb28ef">block_time_multiplier</a>. When <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2b8c561839112c900eda07ec8171abfb">struct_size</a> does not include <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a76efe32409f8e56731cf218c67cb28ef">block_time_multiplier</a> and this value is non-zero, the value in <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a76efe32409f8e56731cf218c67cb28ef">block_time_multiplier</a> is replaced with this value divided by the default value of <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a>. </p>

</div>
</div>
<a id="a0ea4a3f44bad298c9dffcc555f5d4241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea4a3f44bad298c9dffcc555f5d4241">&#9670;&nbsp;</a></span>blocking_switch_threshold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::blocking_switch_threshold = 500</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the minimum latency in the unit of the trace's timestamps (microseconds) for which a maybe-blocking system call (one with a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caa6544f9f8c54496a7befa481c81577b7">TRACE_MARKER_TYPE_MAYBE_BLOCKING_SYSCALL</a> marker) will be treated as blocking and trigger a context switch. </p>

</div>
</div>
<a id="a70309788c8288f6981dffb5bb9513920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70309788c8288f6981dffb5bb9513920">&#9670;&nbsp;</a></span>deps</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9">inter_input_dependency_t</a> <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::deps = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9af3b4cadcd03eac1003ccd1aced5e2823">DEPENDENCY_IGNORE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How inter-input dependencies are handled. </p>

</div>
</div>
<a id="ac627a524c333875673d4a1302e9ee2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac627a524c333875673d4a1302e9ee2f3">&#9670;&nbsp;</a></span>exit_if_fraction_inputs_left</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::exit_if_fraction_inputs_left = 0.1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0ccaba192b7d617035b922db1f3960154406">MAP_TO_ANY_OUTPUT</a>, when an input reaches EOF, if the number of non-EOF inputs left as a fraction of the original inputs is equal to or less than this value then the scheduler exits (sets all outputs to EOF) rather than finishing off the final inputs. This helps avoid long sequences of idles during staggered endings with fewer inputs left than cores and only a small fraction of the total instructions left in those inputs. Since the remaining instruction count is not considered (as it is not available), use discretion when raising this value on uneven inputs. </p>

</div>
</div>
<a id="a0aaac9f5b93b10fa4c72b620312f1bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aaac9f5b93b10fa4c72b620312f1bcd">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8">scheduler_flags_t</a> <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::flags = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a30edfde737fa568af6c815715e32e2b8ad602678474ddeba790605499c3c01c24">SCHEDULER_DEFAULTS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optional flags affecting scheduler behavior. </p>

</div>
</div>
<a id="a02c2216050c0dd876a43990c44919ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c2216050c0dd876a43990c44919ba9">&#9670;&nbsp;</a></span>honor_direct_switches</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::honor_direct_switches = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, the scheduler will attempt to switch to the recorded targets of <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295cae7bcf6a915571421473532017fc86d24">TRACE_MARKER_TYPE_DIRECT_THREAD_SWITCH</a> system call metadata markers regardless of system call latency. Furthermore, the scheduler will model "unscheduled" semantics and honor the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca6033baf3bb4bf61879c01e91e246b115">TRACE_MARKER_TYPE_SYSCALL_UNSCHEDULE</a> and <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caa8af23555ce5778daecf69b0ef0cf200">TRACE_MARKER_TYPE_SYSCALL_SCHEDULE</a> markers. If false, these markers are ignored and only system call latency thresholds are used to determine switches (these markers remain: they are not removed from the trace). </p>

</div>
</div>
<a id="ace64ac5c9ce99ff13be8a80d287d9f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace64ac5c9ce99ff13be8a80d287d9f46">&#9670;&nbsp;</a></span>honor_infinite_timeouts</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::honor_infinite_timeouts = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether an unscheduled-indefinitely input really is unscheduled for an infinite time, or instead is treated as blocked for the maxiumim time (<a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ad3bf45c6ae11854a847a1c5ff27c03a0">block_time_max_us</a>) scaled by <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a76efe32409f8e56731cf218c67cb28ef">block_time_multiplier</a>. </p>

</div>
</div>
<a id="a9e02a6e38c2872b6b0c0dc287772544c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e02a6e38c2872b6b0c0dc287772544c">&#9670;&nbsp;</a></span>kernel_switch_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;ReaderType&gt; <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::kernel_switch_reader</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alternative to <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a5665d877a7b54ed406752c2bf26cebea">kernel_switch_trace_path</a> is to pass a reader and <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ae6b1d12f5c6c169d92d12c045fe653a1">kernel_switch_reader_end</a>. See the description of <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a5665d877a7b54ed406752c2bf26cebea">kernel_switch_trace_path</a>. This field is only examined if <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a5665d877a7b54ed406752c2bf26cebea">kernel_switch_trace_path</a> is empty. The scheduler will call the <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a7d51e5baa505e36110a502f46c676d07">init()</a> function for the reader. </p>

</div>
</div>
<a id="ae6b1d12f5c6c169d92d12c045fe653a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b1d12f5c6c169d92d12c045fe653a1">&#9670;&nbsp;</a></span>kernel_switch_reader_end</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;ReaderType&gt; <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::kernel_switch_reader_end</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The end reader for <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a9e02a6e38c2872b6b0c0dc287772544c">kernel_switch_reader</a>. </p>

</div>
</div>
<a id="a5665d877a7b54ed406752c2bf26cebea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5665d877a7b54ed406752c2bf26cebea">&#9670;&nbsp;</a></span>kernel_switch_trace_path</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::kernel_switch_trace_path</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input file containing template sequences of kernel context switch code. Each sequence must start with a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca0a5457fcd6611866e9cf31de09519ff0">TRACE_MARKER_TYPE_CONTEXT_SWITCH_START</a> marker and end with <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca70a0fea9e8810e597bce02424bb7a1d2">TRACE_MARKER_TYPE_CONTEXT_SWITCH_END</a>. The values of each marker must hold a <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#aebe64f68f713ab5c29c22097e3b9946d">switch_type_t</a> enum value indicating which type of switch it corresponds to. Each sequence can be stored as a separate subfile of an archive file, or concatenated into a single file. Each sequence should be in the regular offline drmemtrace format. The sequence is inserted into the output stream on each context switch of the indicated type. The same file (or reader) must be passed when replaying as this kernel code is not stored when recording. An alternative to passing the file path is to pass <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a9e02a6e38c2872b6b0c0dc287772544c">kernel_switch_reader</a> and <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#ae6b1d12f5c6c169d92d12c045fe653a1">kernel_switch_reader_end</a>. </p>

</div>
</div>
<a id="a0a08d4779407ad848c57c49e12f668d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a08d4779407ad848c57c49e12f668d3">&#9670;&nbsp;</a></span>kernel_syscall_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;ReaderType&gt; <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::kernel_syscall_reader</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alternative to <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#aeffac2cf5ac00980653bbf22b31a51e4">kernel_syscall_trace_path</a> is to pass a reader and <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#afb03123ae868a8da8a499d664336b321">kernel_syscall_reader_end</a>. See the description of <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#aeffac2cf5ac00980653bbf22b31a51e4">kernel_syscall_trace_path</a>. This field is only examined if <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#aeffac2cf5ac00980653bbf22b31a51e4">kernel_syscall_trace_path</a> is empty. The scheduler will call the <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a7d51e5baa505e36110a502f46c676d07">init()</a> function for the reader. </p>

</div>
</div>
<a id="afb03123ae868a8da8a499d664336b321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb03123ae868a8da8a499d664336b321">&#9670;&nbsp;</a></span>kernel_syscall_reader_end</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;ReaderType&gt; <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::kernel_syscall_reader_end</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The end reader for <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0a08d4779407ad848c57c49e12f668d3">kernel_syscall_reader</a>. </p>

</div>
</div>
<a id="aeffac2cf5ac00980653bbf22b31a51e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffac2cf5ac00980653bbf22b31a51e4">&#9670;&nbsp;</a></span>kernel_syscall_trace_path</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::kernel_syscall_trace_path</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input file containing template sequences of kernel system call code. Each sequence must start with a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca13fffec3c874dcd5cc84aa25387b76d3">TRACE_MARKER_TYPE_SYSCALL_TRACE_START</a> marker and end with <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caef6df6ddbdffd994f91edba51c850cde">TRACE_MARKER_TYPE_SYSCALL_TRACE_END</a>. The value of each marker must hold the system call number for the system call it corresponds to. Sequences for multiple system calls are concatenated into a single file. Each sequence should be in the regular offline drmemtrace format. Whenever a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca9c6c0b467a729d1d4c4298bef1892c74">TRACE_MARKER_TYPE_SYSCALL</a> marker is encountered in a trace, if a corresponding sequence with the same marker value exists it is inserted into the output stream after the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca9c6c0b467a729d1d4c4298bef1892c74">TRACE_MARKER_TYPE_SYSCALL</a> marker. The same file (or reader) must be passed when replaying as this kernel code is not stored when recording. An alternative to passing the file path is to pass <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a0a08d4779407ad848c57c49e12f668d3">kernel_syscall_reader</a> and <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#afb03123ae868a8da8a499d664336b321">kernel_syscall_reader_end</a>. </p>

</div>
</div>
<a id="a86653e52217b6c9cf328696e911c4f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86653e52217b6c9cf328696e911c4f57">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0cc">mapping_t</a> <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::mapping = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0ccaba192b7d617035b922db1f3960154406">MAP_TO_ANY_OUTPUT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The mapping of inputs to outputs. </p>

</div>
</div>
<a id="af201380524f570dd73c5e3803eca9ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af201380524f570dd73c5e3803eca9ee4">&#9670;&nbsp;</a></span>migration_threshold_us</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::migration_threshold_us = 500</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The minimum time in microseconds that must have elapsed after an input last ran on an output before that input is allowed to be migrated to a different output. This value is multiplied by <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a> to produce a value that is compared to the "cur_time" parameter to next_record(). </p>

</div>
</div>
<a id="ab318281b3d416a47029f1e530f1bb472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab318281b3d416a47029f1e530f1bb472">&#9670;&nbsp;</a></span>quantum_duration</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::quantum_duration = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated: use <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a287db4eea35cf618e9dcd2d44b1e7e15">quantum_duration_us</a> and <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a> for <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199a731ead7ea1ca4e3248a56b7aefac9ed3">QUANTUM_TIME</a>, or <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a893632f58364745f024b00365beef461">quantum_duration_instrs</a> for <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199a8e189556d69dfb51884cfe5c0bab5196">QUANTUM_INSTRUCTIONS</a>, instead. It is an error to set this to a non-zero value when <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2b8c561839112c900eda07ec8171abfb">struct_size</a> includes <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a287db4eea35cf618e9dcd2d44b1e7e15">quantum_duration_us</a>. When <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a2b8c561839112c900eda07ec8171abfb">struct_size</a> does not include <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a287db4eea35cf618e9dcd2d44b1e7e15">quantum_duration_us</a> and this value is non-zero, the value in <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a287db4eea35cf618e9dcd2d44b1e7e15">quantum_duration_us</a> is replaced with this value divided by the default value of <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a>. </p>

</div>
</div>
<a id="a893632f58364745f024b00365beef461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893632f58364745f024b00365beef461">&#9670;&nbsp;</a></span>quantum_duration_instrs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::quantum_duration_instrs = 10 * 1000 * 1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduling quantum duration for preemption, in instruction count, for <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199a8e189556d69dfb51884cfe5c0bab5196">QUANTUM_INSTRUCTIONS</a>. The time passed to next_record() is ignored for purposes of quantum preempts.</p>
<p>Instructions executed in a quantum may end up higher than the specified value to avoid interruption of the kernel system call sequence. </p>

</div>
</div>
<a id="a287db4eea35cf618e9dcd2d44b1e7e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287db4eea35cf618e9dcd2d44b1e7e15">&#9670;&nbsp;</a></span>quantum_duration_us</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::quantum_duration_us = 5000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The scheduling quantum duration for preemption, in simulated microseconds, for <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199a731ead7ea1ca4e3248a56b7aefac9ed3">QUANTUM_TIME</a>. This value is multiplied by <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a> to produce a value that is compared to the "cur_time" parameter to next_record() to determine when to force a quantum switch. </p>

</div>
</div>
<a id="a9c57c376cbbfab5749e673c2b54ff1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c57c376cbbfab5749e673c2b54ff1fb">&#9670;&nbsp;</a></span>quantum_unit</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199">quantum_unit_t</a> <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::quantum_unit = <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a66d6f6bbc9213a887758d14d32a31199a8e189556d69dfb51884cfe5c0bab5196">QUANTUM_INSTRUCTIONS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The unit of the schedule time quantum. </p>

</div>
</div>
<a id="a9b9eb1d470d20cf68c3fa76250b074fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9eb1d470d20cf68c3fa76250b074fe">&#9670;&nbsp;</a></span>randomize_next_input</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::randomize_next_input = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, enables a mode where the normal methods of choosing the next input based on priority, timestamps (if -sched_order_time is set), and FIFO order are disabled. Instead, the scheduler selects the next input randomly. Output bindings are still honored. This is intended for experimental use in sensitivity studies. </p>

</div>
</div>
<a id="a34eaff9f2887f3469d737f73ad093343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34eaff9f2887f3469d737f73ad093343">&#9670;&nbsp;</a></span>read_inputs_in_init</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::read_inputs_in_init = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, the scheduler will read from each input to determine its filetype during initialization. If false, the filetype will not be available prior to explicit record retrieval by the user, but this may be required for inputs whose sources are not yet set up at scheduler init time (e.g., inputs over blocking pipes with data only becoming available after initializing the scheduler, as happens with online trace analyzers). This must be true for <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a820df460b5bb4bf9f9972ddb7d21f5d9afa1e39bbc41fe11cc3bbbd36b2a13e6e">DEPENDENCY_TIMESTAMPS</a> as it also requires reading ahead. </p>

</div>
</div>
<a id="ab94dd7429c3b333b663526268441d7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94dd7429c3b333b663526268441d7a3">&#9670;&nbsp;</a></span>rebalance_period_us</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::rebalance_period_us = 50000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The period in microseconds at which rebalancing is performed to keep output run queues from becoming uneven. This value is multiplied by <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a57204006ea4057e5a53e21abdc4e5dc3">time_units_per_us</a> to produce a value that is compared to the "cur_time" parameter to next_record(). </p>

</div>
</div>
<a id="a5367da0081dd5caed8d3d0c02fb9b6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5367da0081dd5caed8d3d0c02fb9b6f2">&#9670;&nbsp;</a></span>replay_as_traced_istream</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">archive_istream_t* <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::replay_as_traced_istream = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input stream for replaying the traced schedule when <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0cca62587c4b17b1c7e6f3ad49bb3747b2be">MAP_TO_RECORDED_OUTPUT</a> is specified for more than one output stream (whose count must match the number of traced cores). Alternatively, if <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1input__workload__t.html#ac5caae7fc0c2f6aeb03bd2eba5858621">dynamorio::drmemtrace::scheduler_tmpl_t::input_workload_t.times_of_interest</a> is non-empty, this stream is required for obtaining the mappings between timestamps and instruction ordinals. </p>

</div>
</div>
<a id="a0d951e6e51647de93dc52083157dab81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d951e6e51647de93dc52083157dab81">&#9670;&nbsp;</a></span>schedule_record_ostream</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">archive_ostream_t* <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::schedule_record_ostream = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output stream for recording the schedule for later replay. <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#a7549f7d208bc562f8d1baf44b5eb9649">write_recorded_schedule()</a> must be called when finished to write the in-memory data out to this stream. </p>

</div>
</div>
<a id="aebd6e85c8a7b37a2cbdfc64efc60537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd6e85c8a7b37a2cbdfc64efc60537e">&#9670;&nbsp;</a></span>schedule_replay_istream</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">archive_istream_t* <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::schedule_replay_istream = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input stream for replaying a previously recorded schedule when <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0cca04bdabcbbe2d702570f8b488c89b6398">MAP_AS_PREVIOUSLY</a> is specified. If this is non-nullptr and <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html#afb65a4beaa27ae26649738d2e565c0cca04bdabcbbe2d702570f8b488c89b6398">MAP_AS_PREVIOUSLY</a> is specified, schedule_record_ostream must be nullptr, and most other fields in this struct controlling scheduling are ignored. </p>

</div>
</div>
<a id="a1783ff3a0ff0f81cb38922f8093a9118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1783ff3a0ff0f81cb38922f8093a9118">&#9670;&nbsp;</a></span>single_lockstep_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::single_lockstep_output = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, enables a mode where all outputs are serialized into one global outer layer output. The single global output stream alternates in round-robin lockstep among each core output. The core outputs operate just like they would with no serialization, other than timing differences relative to other core outputs. </p>

</div>
</div>
<a id="a2b8c561839112c900eda07ec8171abfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8c561839112c900eda07ec8171abfb">&#9670;&nbsp;</a></span>struct_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::struct_size = sizeof(<a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html">scheduler_options_t</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the struct for binary-compatible additions. </p>

</div>
</div>
<a id="a6ea3487c8bbdb7ae52212b245c866608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea3487c8bbdb7ae52212b245c866608">&#9670;&nbsp;</a></span>syscall_switch_threshold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::syscall_switch_threshold = 30000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the minimum latency in the unit of the trace's timestamps (microseconds) for which a non-maybe-blocking system call (one without a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caa6544f9f8c54496a7befa481c81577b7">TRACE_MARKER_TYPE_MAYBE_BLOCKING_SYSCALL</a> marker) will be treated as blocking and trigger a context switch. </p>

</div>
</div>
<a id="a57204006ea4057e5a53e21abdc4e5dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57204006ea4057e5a53e21abdc4e5dc3">&#9670;&nbsp;</a></span>time_units_per_us</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::time_units_per_us = 1000.</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many time units for the "cur_time" value passed to next_record() are equivalent to one simulated microsecond. E.g., if the time units are in picoseconds, pass one million here. This is used to scale all of the other parameters that are in microseconds (they all end in "_us": e.g., <a class="el" href="structdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t_1_1scheduler__options__t.html#a287db4eea35cf618e9dcd2d44b1e7e15">quantum_duration_us</a>) so that they operate on the right time scale for the passed-in simulator time (or wall-clock microseconds if no time is passed). The default value is a rough estimate when no accurate simulated time is available: the instruction count is used in that case, and we use the instructions per microsecond for a 2GHz clock at 0.5 IPC as our default. </p>

</div>
</div>
<a id="afbaa418768eead0d256ea889fda40fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaa418768eead0d256ea889fda40fef">&#9670;&nbsp;</a></span>verbosity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordType , typename ReaderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdynamorio_1_1drmemtrace_1_1scheduler__tmpl__t.html">dynamorio::drmemtrace::scheduler_tmpl_t</a>&lt; RecordType, ReaderType &gt;::scheduler_options_t::verbosity = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If &gt; 0, diagnostic messages are printed to stderr. Higher values produce more frequent diagnostics. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/runner/work/dynamorio/dynamorio/build_release-64/clients/include/drmemtrace/<a class="el" href="scheduler_8h.html">scheduler.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 11.90.20188 --- Fri Apr 11 2025 03:32:29 &nbsp; <img border=0 src="favicon.png">
</small></address>
