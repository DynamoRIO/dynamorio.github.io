---
title: "Google Workload Traces (Version 2)"
layout: default
permalink: /google_workload_traces.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Google Workload Traces (Version 2) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>With the rapid growth of internet services and cloud computing, workloads on warehouse-scale computers (WSCs) have become an important segment of todayâ€™s computing market. These workloads differ from others in their requirements of on-demand scalability, elasticity and availability. They have fundamentally different characteristics from traditional benchmarks and require changes to modern computer architecture to achieve optimal efficiency. Google is sharing instruction and memory address traces from workloads running in Google data centers so that computer architecture researchers can study and develop new architecture ideas to improve the performance and efficiency of this important class of workloads. To protect Google's intellectual property, these traces have had their original ISA replaced with a synthetic ISA that we call <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a>. This synthetic ISA removes architecture specific details (e.g., the opcode of instructions), while still providing enough information (e.g., register dependencies, instruction categories) to perform meaningful analyses and simulations.</p>
<h1><a class="anchor" id="sec_google_format"></a>
Public Trace Format</h1>
<p>The Google workload traces are captured using DynamoRIO's <a class="el" href="page_drcachesim.html">drmemtrace</a>. The traces are records of instruction and memory accesses as described at <a class="el" href="sec_drcachesim_format.html">Trace Format</a>. While memory accesses are left unchanged compared to the original trace, instructions follow the <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> synthetic ISA.</p>
<p><a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> has the purpose of preserving register dependencies and giving hints on the type of operation an instruction performs. For this reason, all operands that are not registers (e.g., memory and immediate operands) are not present. Memory operations of a <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> can be inferred from the subsequent <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a00e926de2230d3f712dcae422e6cb59ca018585565e72f9ebe6723e089f3d343d">dynamorio::drmemtrace::TRACE_TYPE_READ</a> and <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a00e926de2230d3f712dcae422e6cb59cad1b528a4a5a6797950207e98766d33ff">dynamorio::drmemtrace::TRACE_TYPE_WRITE</a> records. Note that if a memory operand of the original ISA instruction uses a register, its corresponding virtual register will be present in the list of source register operands of the corresponding <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instruction.</p>
<p>Being a synthetic ISA, some routines that work on instructions coming from an actual ISA (such as <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aabd60fe0abfbb90ba431205b7e5345ac0">DR_ISA_AMD64</a>) are not supported (e.g., <a class="el" href="dr__ir__decode_8h.html#af4a2c830c95757037eaa1a192a22aa3a">decode_sizeof()</a>). We do support <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> and <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>: to decode an encoded <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instruction into an <a class="el" href="structinstr__t.html">instr_t</a>.</p>
<p>A <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> contains the following information:</p><ul>
<li>Categories: composed by <a class="el" href="dr__ir__instr_8h.html#a6a293267f240f04a49586895b3b67893">dr_instr_category_t</a> values, they indicate the type of operation performed (e.g., a load, a store, a floating point math operation, a branch, etc.). Note that categories are composable, hence more than one category can be set. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a2bb8455e57af9ec7f3e60c04aa5723bc">instr_get_category()</a>.</li>
<li>Arithmetic flags: we don't distinguish between different flags, we only report if at least one arithmetic flag was read (all arithmetic flags will be set to read) and/or written (all arithmetic flags will be set to written). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a08af81c9de9f4f78c309ca59016398e4">instr_get_arith_flags()</a>.</li>
<li>Number of source and destination operands: we only consider register operands. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#ab264f741f5a1edea068dbabb90b4e4c6">instr_num_srcs()</a> and <a class="el" href="dr__ir__instr_8h.html#a3574118088b6a3a5a9b3b7308da90ed7">instr_num_dsts()</a>. Memory operands can be deduced by subsequent read and write records in the trace.</li>
<li>Source operation size: is the largest source operand the original ISA instruction operated on. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a04d874af218c27761793d6bf4437e7ab">instr_get_operation_size()</a>.</li>
<li>List of register operand identifiers: they are contained in <a class="el" href="structopnd__t.html">opnd_t</a> lists, separated in source and destination. Note that these <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> identifiers are virtual and it should not be assumed that they belong to any DR_REG_ enum value of any specific architecture. These identifiers are meant for tracking register dependencies with respect to other <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instructions only. These lists can be obtained by walking the <a class="el" href="structinstr__t.html">instr_t</a> operands with <a class="el" href="dr__ir__instr_8h.html#a82807d01f70f547181c3b09e09548f6b">instr_get_dst()</a> and <a class="el" href="dr__ir__instr_8h.html#a38157d3c73c39d022efd47ddba1f666d">instr_get_src()</a>.</li>
<li>ISA mode: is always <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a>. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a4362c9281f6555d65240e447eed9e5c0">instr_get_isa_mode()</a>.</li>
<li>Encoding bytes: an array of bytes containing the <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> encoding. Note that this information is present only for decoded instructions (i.e., <a class="el" href="structinstr__t.html">instr_t</a> generated by <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> or <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#adf6288f48a76fdea2523a97ec5664d87">instr_get_raw_bits()</a>.</li>
<li>Length: the length of the encoded instruction in bytes. Note that this information is present only for decoded instructions (i.e., <a class="el" href="structinstr__t.html">instr_t</a> generated by <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> or <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#aad3aa16a7ca0f44f6721cb308a80a978">instr_length()</a>. Be aware that in Google Workload Traces the instruction fetch size of a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">dynamorio::drmemtrace::memref_t</a> and the <a class="el" href="dr__ir__instr_8h.html#aad3aa16a7ca0f44f6721cb308a80a978">instr_length()</a> of the corresponding fetched instruction do not match! To allow analyses and simulations of front-end behavior to have a realistic size of fetched instructions, we kept the instruction fetch size to be the same as in the original ISA instruction.</li>
</ul>
<p>Note that all routines that operate on <a class="el" href="structinstr__t.html">instr_t</a> and <a class="el" href="structopnd__t.html">opnd_t</a> are also supported for <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instructions and their operands. However, querying information outside of those described above will return the zeroed value set by <a class="el" href="dr__ir__instr_8h.html#a9d9a1662aed6669a42a8284dae0e8019">instr_create()</a> or <a class="el" href="dr__ir__instr_8h.html#af7e998e183e87480e7fd82240ff6633d">instr_init()</a> when the <a class="el" href="structinstr__t.html">instr_t</a> was created.</p>
<p>On top of instructions and memory accesses, traces also have <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295c">dynamorio::drmemtrace::trace_marker_type_t</a> markers. All markers of the original trace are present, except for:</p><ul>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca0577a502881eaa15ea429d83f64e4ce5">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_IDX</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca9c6c0b467a729d1d4c4298bef1892c74">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca13fffec3c874dcd5cc84aa25387b76d3">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_TRACE_START</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caef6df6ddbdffd994f91edba51c850cde">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_TRACE_END</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295cac4123c88a189fe7b52ceee6b7cab48ce">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_FAILED</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caeab5ab5189617728fec57d491ef1d63d">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SIGNAL_NUMBER</a></li>
</ul>
<p>Which have been removed.</p>
<p>Because tracing overhead results into inflated context switches, the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca0f5122cab14b6654b276de4aa7f8183c">dynamorio::drmemtrace::TRACE_MARKER_TYPE_CPU_ID</a> values have been modified to "unknown CPU" to avoid confusion. We recommend users to use our scheduler (see <a class="el" href="sec_drcachesim_sched.html">Trace Scheduler</a>) for a realistic schedule of a trace's threads.</p>
<p>Also, we preserved the following markers, but only for SYS_futex functions:</p><ul>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca5c6f08548563cb1456a4f09b9b5c3f59">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_ID</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caf3a4f4b91cea5bb55ed8d9caae221e7c">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_ARG</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca58ff903618a785cb45ba4c57900db24f">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_RETVAL</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caaf1dc361b0b77c739bf4d0f87c7c43b9">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_RETADDR</a></li>
</ul>
<p>Every trace has a v2p.textproto and an info.textproto file associated with it.</p>
<p>The v2p.textproto file provides a plausible virtual to physical mapping of the virtual addresses present in a trace for more realistic TLB simulations. This is a static virtual to physical mapping with 2 MB pages. Users can generate different mappings (e.g., smaller page size) by modifying this file, or create their own mapping following the same v2p.textproto format.</p>
<p>To run the TLB_simulator tool leveraging the provided v2p.textproto, use: </p><pre class="fragment">drrun -t drmemtrace -tool TLB_simulator -indir ${PATH_TO_TRACE} -use_physical -v2p_file ${PATH_TO_TRACE}/aux/v2p.textproto
</pre><p>The info.textproto file provides users with additional, human-readable information about a trace. Unlike v2p.textproto, this file is currently not intended to be used with any DynamoRIO tool. The file contains information on phases of the underlying workload and the number of peak live cores (i.e., the maximum number of cores used at the same time during the executon of the traced workload). We recommend users to set their trace simulations to use the provided number of peak live cores and scale the LLC accordingly, if the peak live cores is not the whole socket.</p>
<p>These traces are supported starting from DynamoRIO 11.3.</p>
<h1><a class="anchor" id="Simulation"></a>
Recommendations</h1>
<p>As noted above, for each workload, we recommend using our scheduler (see <a class="el" href="sec_drcachesim_sched.html">Trace Scheduler</a>) to interleave the individual software thread traces to produce a realistic hardware-view schedule for that workload. Configure the scheduler for the number of cores listed in the info.textproto file as the peak live cores.</p>
<p>We recommend configuring simulation to use the same peak live core count, simulating all cores simultaneously. Scale the LLC accordingly if the peak live cores is not the whole socket. We strongly caution against simulating a single core in isolation, as this will not produce representative results.</p>
<p>We do not recommend creating a schedule and then independently feeding each core's view into the simulator. This can lead to drift where cores no longer align and two software threads could then run simultaneously on two cores. Instead, use online conversion into the simulator's input format, with the scheduler integrated into the worfklow. We recommend using dynamic scheduling with the scheduler selecting the schedule as the simulation unfolds, so the simulated time drives the scheduling. For repeatable schedules, leverage the record-replay capability of the scheduler: record one schedule and replay in subsequent runs. When replaying a previously recorded schedule, the scheduler will cause a core that gets ahead to wait and not continue until other cores catch up.</p>
<h1><a class="anchor" id="sec_google_get"></a>
Getting the Traces</h1>
<p>The Google Workload Traces can be downloaded from:</p>
<ul>
<li><a href="https://console.cloud.google.com/storage/browser/external-traces-v2">Google workload trace folder</a></li>
</ul>
<p>Directory structure: </p><pre class="fragment">CHANGELOG.txt
CONTRIBUTING.txt
LICENSE.txt
README.txt
workload_name/
  trace/
    &lt;uuid&gt;.&lt;tid&gt;.memtrace.zip
  aux/
    info.textproto
    v2p.textproto
</pre><h1><a class="anchor" id="sec_google_help"></a>
Getting Help and Reporting Bugs</h1>
<p>The Google Workload Traces are essentially inputs to drive third party tools (such as analyzers or simulators, including those provided here: <a class="el" href="sec_drcachesim_tools.html">Analysis Tool Suite</a>). If you encounter a crash in a tool provided by a third party, please locate the issue tracker for the tool you are using and report the crash there. If you believe the issue is with the Google Workload Traces or with DynamoRIO or tools provided with DynamoRIO, you can file an issue as described at <a class="el" href="page_bug_reporting.html">Reporting Problems</a>.</p>
<p>For general questions, or if you are not sure whether the problem you hit is a bug in your own code or in provided code, use the <a href="http://groups.google.com/group/dynamorio-users">DynamoRIO users group mailing list/discussion forum</a> rather than opening an issue in the tracker. The users list will reach a wider audience of people who might have an answer, and it will reach other users who may find the information beneficial.</p>
<h1><a class="anchor" id="sec_google_contrib"></a>
Contributing</h1>
<p>We welcome contributions to the Google workload trace project. The goal of providing the Google workload traces is to enable computer architecture researchers to develop insights and new architecture ideas to improve the performance and efficiency of workloads that run on warehouse-scale computers.</p>
<p>You can contribute to the project in many ways:</p>
<ul>
<li>Providing suggestions for improving trace formats.</li>
<li>Sharing and collaborating on architecture research.</li>
<li>Reporting issues: see <a class="el" href="google_workload_traces.html#sec_google_help">Getting Help and Reporting Bugs</a> .</li>
</ul>
<h1><a class="anchor" id="sec_google_cite"></a>
Cite Google Workload Traces</h1>
<p>If you would like to cite this work, you can use the following BibTeX entry:</p>
<pre class="fragment">@misc{Google_Workload_Traces_Version_2,
  title = {Google Workload Traces Version 2},
  howpublished = {\url{https://console.cloud.google.com/storage/browser/external-traces-v2}},
  note = {Accessed: yyyy-mm-dd}
}
</pre><h1><a class="anchor" id="sec_google_common_issues"></a>
Common Issues</h1>
<p>Here we collect common issues that some users might experience when using the Google Workload Traces.</p>
<ul>
<li>Depending on the Linux distribution used, there might be a "nofile" threshold for the number of files a single process can open that is set too low (e.g., 1024). This threshold can be increased using "ulimit -n 8192". A threshold of 8192 is enough for Google Workload Traces. Consider adding this command to your ".bashrc". A low "nofile" threshold is problematic when a DynamoRIO analyzer or scheduler operates on a whole Google trace, which can have over 2000 trace files (one per software thread). This can result in "Failed to initialize scheduler: Failed to open PATH/TO/MEMTRACE.ZIP". If this happens, please increase the "nofile" threshold.</li>
</ul>
<h1><a class="anchor" id="sec_public_v1_deprecated"></a>
Deprecated Google Workload Traces (Version 1)</h1>
<p>The previous version of Google workload traces contains a subset of the information of the current traces and has been deprecated. Please use the current version described above.</p>
<p>The previous version can still be found at:</p>
<ul>
<li><a href="https://console.cloud.google.com/storage/browser/external-traces">Google workload trace folder (Version 1)</a></li>
</ul>
<p>DynamoRIO 11.0 is the latest version that supports these traces. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 11.90.20433 --- Fri Dec 12 2025 03:32:53 &nbsp; <img border=0 src="favicon.png">
</small></address>
