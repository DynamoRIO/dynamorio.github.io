---
title: "Google Workload Traces (Version 2)"
layout: default
permalink: /google_workload_traces.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Google Workload Traces (Version 2) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>With the rapid growth of internet services and cloud computing, workloads on warehouse-scale computers (WSCs) have become an important segment of todayâ€™s computing market. These workloads differ from others in their requirements of on-demand scalability, elasticity and availability. They have fundamentally different characteristics from traditional benchmarks and require changes to modern computer architecture to achieve optimal efficiency. Google is sharing instruction and memory address traces from workloads running in Google data centers so that computer architecture researchers can study and develop new architecture ideas to improve the performance and efficiency of this important class of workloads. To protect Google's intellectual property, these traces have had their original ISA replaced with a synthetic ISA that we call <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a>. This synthetic ISA removes architecture specific details (e.g., the opcode of instructions), while still providing enough information (e.g., register dependencies, instruction categories) to perform meaningful analyses and simulations.</p>
<h1><a class="anchor" id="sec_google_format"></a>
Public Trace Format</h1>
<p>The Google workload traces are captured using DynamoRIO's <a class="el" href="page_drcachesim.html">drmemtrace</a>. The traces are records of instruction and memory accesses as described at <a class="el" href="sec_drcachesim_format.html">Trace Format</a>. While memory accesses are left unchanged compared to the original trace, instructions follow the <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> synthetic ISA.</p>
<p><a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> has the purpose of preserving register dependencies and giving hints on the type of operation an instruction performs. For this reason, all operands that are not registers (e.g., memory and immediate operands) are not present. Memory operations of a <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> can be inferred from the subsequent <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a00e926de2230d3f712dcae422e6cb59ca018585565e72f9ebe6723e089f3d343d">dynamorio::drmemtrace::TRACE_TYPE_READ</a> and <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a00e926de2230d3f712dcae422e6cb59cad1b528a4a5a6797950207e98766d33ff">dynamorio::drmemtrace::TRACE_TYPE_WRITE</a> records. Note that if a memory operand of the original ISA instruction uses a register, its corresponding virtual register will be present in the list of source register operands of the corresponding <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instruction.</p>
<p>Being a synthetic ISA, some routines that work on instructions coming from an actual ISA (such as <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aabd60fe0abfbb90ba431205b7e5345ac0">DR_ISA_AMD64</a>) are not supported (e.g., <a class="el" href="dr__ir__decode_8h.html#af4a2c830c95757037eaa1a192a22aa3a">decode_sizeof()</a>). We do support <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> and <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>: to decode an encoded <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instruction into an <a class="el" href="structinstr__t.html">instr_t</a>.</p>
<p>A <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> contains the following information:</p><ul>
<li>Categories: composed by <a class="el" href="dr__ir__instr_8h.html#a6a293267f240f04a49586895b3b67893">dr_instr_category_t</a> values, they indicate the type of operation performed (e.g., a load, a store, a floating point math operation, a branch, etc.). Note that categories are composable, hence more than one category can be set. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a2bb8455e57af9ec7f3e60c04aa5723bc">instr_get_category()</a>.</li>
<li>Arithmetic flags: we don't distinguish between different flags, we only report if at least one arithmetic flag was read (all arithmetic flags will be set to read) and/or written (all arithmetic flags will be set to written). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a08af81c9de9f4f78c309ca59016398e4">instr_get_arith_flags()</a>.</li>
<li>Number of source and destination operands: we only consider register operands. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#ab264f741f5a1edea068dbabb90b4e4c6">instr_num_srcs()</a> and <a class="el" href="dr__ir__instr_8h.html#a3574118088b6a3a5a9b3b7308da90ed7">instr_num_dsts()</a>. Memory operands can be deduced by subsequent read and write records in the trace.</li>
<li>Source operation size: is the largest source operand the original ISA instruction operated on. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a04d874af218c27761793d6bf4437e7ab">instr_get_operation_size()</a>.</li>
<li>List of register operand identifiers: they are contained in <a class="el" href="structopnd__t.html">opnd_t</a> lists, separated in source and destination. Note that these <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> identifiers are virtual and it should not be assumed that they belong to any DR_REG_ enum value of any specific architecture. These identifiers are meant for tracking register dependencies with respect to other <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instructions only. These lists can be obtained by walking the <a class="el" href="structinstr__t.html">instr_t</a> operands with <a class="el" href="dr__ir__instr_8h.html#a82807d01f70f547181c3b09e09548f6b">instr_get_dst()</a> and <a class="el" href="dr__ir__instr_8h.html#a38157d3c73c39d022efd47ddba1f666d">instr_get_src()</a>.</li>
<li>ISA mode: is always <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a>. This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#a4362c9281f6555d65240e447eed9e5c0">instr_get_isa_mode()</a>.</li>
<li>Encoding bytes: an array of bytes containing the <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> <a class="el" href="structinstr__t.html">instr_t</a> encoding. Note that this information is present only for decoded instructions (i.e., <a class="el" href="structinstr__t.html">instr_t</a> generated by <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> or <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#adf6288f48a76fdea2523a97ec5664d87">instr_get_raw_bits()</a>.</li>
<li>Length: the length of the encoded instruction in bytes. Note that this information is present only for decoded instructions (i.e., <a class="el" href="structinstr__t.html">instr_t</a> generated by <a class="el" href="dr__ir__decode_8h.html#a5ca2a278008e547130218e8cfde44e3d">decode()</a> or <a class="el" href="dr__ir__decode_8h.html#abf858ce8d17c1221ea6121f1bb437348">decode_from_copy()</a>). This information can be obtained using <a class="el" href="dr__ir__instr_8h.html#aad3aa16a7ca0f44f6721cb308a80a978">instr_length()</a>. Be aware that in Google Workload Traces the instruction fetch size of a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">dynamorio::drmemtrace::memref_t</a> and the <a class="el" href="dr__ir__instr_8h.html#aad3aa16a7ca0f44f6721cb308a80a978">instr_length()</a> of the corresponding fetched instruction do not match! To allow analyses and simulations of front-end behavior to have a realistic size of fetched instructions, we kept the instruction fetch size to be the same as in the original ISA instruction.</li>
</ul>
<p>Note that all routines that operate on <a class="el" href="structinstr__t.html">instr_t</a> and <a class="el" href="structopnd__t.html">opnd_t</a> are also supported for <a class="el" href="dr__ir__encode_8h.html#a00e03b2e5e75a83eacf9a0ee1674074aa1bbcfa1df3fffff3d96b357f9a2290d3">DR_ISA_REGDEPS</a> instructions and their operands. However, querying information outside of those described above will return the zeroed value set by <a class="el" href="dr__ir__instr_8h.html#a9d9a1662aed6669a42a8284dae0e8019">instr_create()</a> or <a class="el" href="dr__ir__instr_8h.html#af7e998e183e87480e7fd82240ff6633d">instr_init()</a> when the <a class="el" href="structinstr__t.html">instr_t</a> was created.</p>
<p>On top of instructions and memory accesses, traces also have <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295c">dynamorio::drmemtrace::trace_marker_type_t</a> markers. All markers of the original trace are present, except for:</p><ul>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca0577a502881eaa15ea429d83f64e4ce5">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_IDX</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca9c6c0b467a729d1d4c4298bef1892c74">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca13fffec3c874dcd5cc84aa25387b76d3">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_TRACE_START</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caef6df6ddbdffd994f91edba51c850cde">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_TRACE_END</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295cac4123c88a189fe7b52ceee6b7cab48ce">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SYSCALL_FAILED</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caeab5ab5189617728fec57d491ef1d63d">dynamorio::drmemtrace::TRACE_MARKER_TYPE_SIGNAL_NUMBER</a></li>
</ul>
<p>Which have been removed.</p>
<p>Because tracing overhead results into inflated context switches, the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca0f5122cab14b6654b276de4aa7f8183c">dynamorio::drmemtrace::TRACE_MARKER_TYPE_CPU_ID</a> values have been modified to "unknown CPU" to avoid confusion. We recommend users to use our scheduler (see <a class="el" href="sec_drcachesim_sched.html">Trace Scheduler</a>) for a realistic schedule of a trace's threads.</p>
<p>Also, we preserved the following markers, but only for SYS_futex functions:</p><ul>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca5c6f08548563cb1456a4f09b9b5c3f59">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_ID</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caf3a4f4b91cea5bb55ed8d9caae221e7c">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_ARG</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca58ff903618a785cb45ba4c57900db24f">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_RETVAL</a></li>
<li><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295caaf1dc361b0b77c739bf4d0f87c7c43b9">dynamorio::drmemtrace::TRACE_MARKER_TYPE_FUNC_RETADDR</a></li>
</ul>
<p>Every trace has a v2p.textproto and an info.textproto file associated with it.</p>
<p>The v2p.textproto file provides a plausible virtual to physical mapping of the virtual addresses present in a trace for more realistic TLB simulations. This is a static virtual to physical mapping with 2 MB pages. Users can generate different mappings (e.g., smaller page size) by modifying this file, or create their own mapping following the same v2p.textproto format.</p>
<p>To run the TLB_simulator tool leveraging the provided v2p.textproto, use: </p><pre class="fragment">drrun -t drmemtrace -tool TLB_simulator -indir ${PATH_TO_TRACE} -use_physical -v2p_file ${PATH_TO_TRACE}/aux/v2p.textproto
</pre><p>The info.textproto file provides users with additional, human-readable information about a trace. Unlike v2p.textproto, this file is currently not intended to be used with any DynamoRIO tool. The file contains information on phases of the underlying workload and the number of peak live cores (i.e., the maximum number of cores used at the same time during the executon of the traced workload). We recommend users to set their trace simulations to use the provided number of peak live cores and scale the LLC accordingly, if the peak live cores is not the whole socket.</p>
<p>These traces are supported starting from DynamoRIO 11.3.</p>
<h1><a class="anchor" id="sec_google_get"></a>
Getting the Traces</h1>
<p>The Google Workload Traces can be downloaded from:</p>
<ul>
<li><a href="https://console.cloud.google.com/storage/browser/external-traces-v2">Google workload trace folder</a></li>
</ul>
<p>Directory structure: </p><pre class="fragment">CHANGELOG.txt
CONTRIBUTING.txt
LICENSE.txt
README.txt
workload_name/
  trace/
    &lt;uuid&gt;.&lt;tid&gt;.memtrace.zip
  aux/
    info.textproto
    v2p.textproto
</pre><h1><a class="anchor" id="sec_google_help"></a>
Getting Help and Reporting Bugs</h1>
<p>The Google Workload Traces are essentially inputs to drive third party tools (such as analyzers or simulators, including those provided here: <a class="el" href="sec_drcachesim_tools.html">Analysis Tool Suite</a>). If you encounter a crash in a tool provided by a third party, please locate the issue tracker for the tool you are using and report the crash there. If you believe the issue is with the Google Workload Traces or with DynamoRIO or tools provided with DynamoRIO, you can file an issue as described at <a class="el" href="page_bug_reporting.html">Reporting Problems</a>.</p>
<p>For general questions, or if you are not sure whether the problem you hit is a bug in your own code or in provided code, use the <a href="http://groups.google.com/group/dynamorio-users">DynamoRIO users group mailing list/discussion forum</a> rather than opening an issue in the tracker. The users list will reach a wider audience of people who might have an answer, and it will reach other users who may find the information beneficial.</p>
<h1><a class="anchor" id="sec_google_contrib"></a>
Contributing</h1>
<p>We welcome contributions to the Google workload trace project. The goal of providing the Google workload traces is to enable computer architecture researchers to develop insights and new architecture ideas to improve the performance and efficiency of workloads that run on warehouse-scale computers.</p>
<p>You can contribute to the project in many ways:</p>
<ul>
<li>Providing suggestions for improving trace formats.</li>
<li>Sharing and collaborating on architecture research.</li>
<li>Reporting issues: see <a class="el" href="google_workload_traces.html#sec_google_help">Getting Help and Reporting Bugs</a> .</li>
</ul>
<h1><a class="anchor" id="sec_google_cite"></a>
Cite Google Workload Traces</h1>
<p>If you would like to cite this work, you can use the following BibTeX entry:</p>
<pre class="fragment">@misc{Google_Workload_Traces_Version_2,
  title = {Google Workload Traces Version 2},
  howpublished = {\url{https://console.cloud.google.com/storage/browser/external-traces-v2}},
  note = {Accessed: yyyy-mm-dd}
}
</pre><h1><a class="anchor" id="sec_public_v1_deprecated"></a>
Deprecated Google Workload Traces (Version 1)</h1>
<p>The previous version of Google workload traces contains a subset of the information of the current traces and has been deprecated. Please use the current version described above.</p>
<p>The previous version can still be found at:</p>
<ul>
<li><a href="https://console.cloud.google.com/storage/browser/external-traces">Google workload trace folder (Version 1)</a></li>
</ul>
<p>DynamoRIO 11.0 is the latest version that supports these traces. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 11.90.20188 --- Fri Apr 11 2025 03:32:29 &nbsp; <img border=0 src="favicon.png">
</small></address>
