---
title: "dynamorio::drmemtrace::decode_cache_t&lt; DecodeInfo &gt; Class Template Reference"
layout: default
permalink: /classdynamorio_1_1drmemtrace_1_1decode__cache__t.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedynamorio.html">dynamorio</a></li><li class="navelem"><a class="el" href="namespacedynamorio_1_1drmemtrace.html">drmemtrace</a></li><li class="navelem"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">decode_cache_t</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">dynamorio::drmemtrace::decode_cache_t&lt; DecodeInfo &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;decode_cache.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dynamorio::drmemtrace::decode_cache_t&lt; DecodeInfo &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="/images/classdynamorio_1_1drmemtrace_1_1decode__cache__t.png" usemap="#dynamorio::drmemtrace::decode_5Fcache_5Ft_3C_20DecodeInfo_20_3E_map" alt=""/>
  <map id="dynamorio::drmemtrace::decode_5Fcache_5Ft_3C_20DecodeInfo_20_3E_map" name="dynamorio::drmemtrace::decode_5Fcache_5Ft_3C_20DecodeInfo_20_3E_map">
<area href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html" alt="dynamorio::drmemtrace::decode_cache_base_t" shape="rect" coords="0,0,358,24"/>
<area href="classdynamorio_1_1drmemtrace_1_1test__decode__cache__t.html" alt="dynamorio::drmemtrace::test_decode_cache_t&lt; DecodeInfo &gt;" shape="rect" coords="0,112,358,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4deea879b476a4a0874cca421d07ff7e"><td class="memItemLeft" align="right" valign="top">DecodeInfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#a4deea879b476a4a0874cca421d07ff7e">get_decode_info</a> (app_pc pc)</td></tr>
<tr class="separator:a4deea879b476a4a0874cca421d07ff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435da335a7f8b80e2a17a97d1a34d6a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#a6435da335a7f8b80e2a17a97d1a34d6a">add_decode_info</a> (const <a class="el" href="structdynamorio_1_1drmemtrace_1_1__memref__instr__t.html">dynamorio::drmemtrace::_memref_instr_t</a> &amp;memref_instr, DecodeInfo *&amp;cached_decode_info)</td></tr>
<tr class="separator:a6435da335a7f8b80e2a17a97d1a34d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9f72a3cb63055b5d5c790b83bf0e4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#af5f9f72a3cb63055b5d5c790b83bf0e4">init</a> (<a class="el" href="namespacedynamorio_1_1drmemtrace.html#a017717a4b9ef5ae1f6d1fef1df834baa">offline_file_type_t</a> filetype, const std::string &amp;module_file_path=&quot;&quot;, const std::string &amp;alt_module_dir=&quot;&quot;)</td></tr>
<tr class="separator:af5f9f72a3cb63055b5d5c790b83bf0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c210e5268cc9581d0fb33350ab84512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#a7c210e5268cc9581d0fb33350ab84512">clear_cache</a> ()</td></tr>
<tr class="separator:a7c210e5268cc9581d0fb33350ab84512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t')"><img src="/images/closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html">dynamorio::drmemtrace::decode_cache_base_t</a></td></tr>
<tr class="memitem:abe7ec78e79df5f0716429591d91506bf inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html#abe7ec78e79df5f0716429591d91506bf">decode_cache_base_t</a> (unsigned int verbosity)</td></tr>
<tr class="separator:abe7ec78e79df5f0716429591d91506bf inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ee9f16c149ed8cb946c7ec6cfcf74c inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html#a58ee9f16c149ed8cb946c7ec6cfcf74c">init_module_mapper</a> (const std::string &amp;module_file_path, const std::string &amp;alt_module_dir)</td></tr>
<tr class="separator:a58ee9f16c149ed8cb946c7ec6cfcf74c inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92aac41d9c88a4a3b87b66c9df08feec inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html#a92aac41d9c88a4a3b87b66c9df08feec">find_mapped_trace_address</a> (app_pc trace_pc, app_pc &amp;decode_pc)</td></tr>
<tr class="separator:a92aac41d9c88a4a3b87b66c9df08feec inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a130be16f5977673dd841f073821366 inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedynamorio_1_1drmemtrace.html#a017717a4b9ef5ae1f6d1fef1df834baa">offline_file_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html#a2a130be16f5977673dd841f073821366">build_arch_file_type</a> ()</td></tr>
<tr class="separator:a2a130be16f5977673dd841f073821366 inherit pro_methods_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t')"><img src="/images/closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html">dynamorio::drmemtrace::decode_cache_base_t</a></td></tr>
<tr class="memitem:abe0355194b56d18227d39e0311ec14b9 inherit pro_attribs_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html#abe0355194b56d18227d39e0311ec14b9">use_module_mapper_</a> = false</td></tr>
<tr class="separator:abe0355194b56d18227d39e0311ec14b9 inherit pro_attribs_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646ef92272fa7a6abeb515190389afb2 inherit pro_attribs_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__base__t.html#a646ef92272fa7a6abeb515190389afb2">verbosity_</a> = 0</td></tr>
<tr class="separator:a646ef92272fa7a6abeb515190389afb2 inherit pro_attribs_classdynamorio_1_1drmemtrace_1_1decode__cache__base__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DecodeInfo&gt;<br />
class dynamorio::drmemtrace::decode_cache_t&lt; DecodeInfo &gt;</h3>

<p>A cache to store decode info for instructions per observed app pc. The template arg DecodeInfo is a class derived from <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__info__base__t.html">dynamorio::drmemtrace::decode_info_base_t</a> which implements the set_decode_info_derived() function that derives the required decode info from an <a class="el" href="structinstr__t.html">instr_t</a> object and raw encoding bytes when invoked by <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a>. This class handles the heavy lifting of determining the address where the instruction raw bytes can be found (which can be inside the instr <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">memref_t</a>, or in the mapped application binaries for legacy traces), actually producing the decoded <a class="el" href="structinstr__t.html">instr_t</a>, and managing the DecodeInfo cache (which includes invalidating stale DecodeInfo based on the encoding_is_new field in traces with embedded encodings).</p>
<p>In general use, <code>include_decoded_instr_</code> should be set to true, but may be set to false if the user wants to perform decoding themselves. In this case, the <a class="el" href="structinstr__t.html">instr_t</a> provided to set_decode_info_derived() will be nullptr, and the <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a> object merely acts as a cache and provider of the instruction raw bytes.</p>
<p>The decoded <a class="el" href="structinstr__t.html">instr_t</a> may be made to persist beyond the set_decode_info() calls by constructing the <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a> object with <code>persist_decoded_instr_</code> set to true.</p>
<p><code>include_decoded_instr_</code> cannot be false if <code>persist_decoded_instr_</code> is true.</p>
<p>Usage note: after constructing an object, <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#af5f9f72a3cb63055b5d5c790b83bf0e4">init()</a> must be called. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6435da335a7f8b80e2a17a97d1a34d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435da335a7f8b80e2a17a97d1a34d6a">&#9670;&nbsp;</a></span>add_decode_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DecodeInfo &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a>&lt; DecodeInfo &gt;::add_decode_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdynamorio_1_1drmemtrace_1_1__memref__instr__t.html">dynamorio::drmemtrace::_memref_instr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>memref_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecodeInfo *&amp;&#160;</td>
          <td class="paramname"><em>cached_decode_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds decode info for the given <code>memref_instr</code> if it is not yet recorded. or if it contains a new encoding.</p>
<p>Uses the embedded encodings in the trace or, if <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#af5f9f72a3cb63055b5d5c790b83bf0e4">init()</a> was invoked with a module file path, the encodings from the instantiated <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">dynamorio::drmemtrace::module_mapper_t</a>.</p>
<p>If there is a failure either during decoding or creation of the DecodeInfo object, a DecodeInfo that returns is_valid() == false and the relevant error info in get_error_string() will be added to the cache.</p>
<p>Returns a pointer to whatever DecodeInfo is present in the cache in the <code>cached_decode_info</code> reference pointer parameter, or a nullptr if none is cached. This helps avoid a repeated lookup in a subsequent <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#a4deea879b476a4a0874cca421d07ff7e">get_decode_info()</a> call.</p>
<p>Returns the error string, or an empty string if there was no error. A valid DecodeInfo is guaranteed to be in the cache if there was no error. </p>

</div>
</div>
<a id="a7c210e5268cc9581d0fb33350ab84512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c210e5268cc9581d0fb33350ab84512">&#9670;&nbsp;</a></span>clear_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DecodeInfo &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a>&lt; DecodeInfo &gt;::clear_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all cached decode info entries.</p>
<p>Typically analysis tools like to keep their per-shard data around till all shards are done processing (so they can combine the shards and use the results), but this API optionally allows tools to keep memory consumption in check by discarding the decode cache entries in parallel_shard_exit(), since it's very likely that the decode cache is not needed for result computation.</p>
<p>This does not affect the state of any initialized module mapper, which is still cleaned up during destruction. </p>

</div>
</div>
<a id="a4deea879b476a4a0874cca421d07ff7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4deea879b476a4a0874cca421d07ff7e">&#9670;&nbsp;</a></span>get_decode_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DecodeInfo &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DecodeInfo* <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a>&lt; DecodeInfo &gt;::get_decode_info </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the DecodeInfo available for the instruction at <code>pc</code>. Returns nullptr if no instruction is known at that <code>pc</code>. Returns the default-constructed DecodeInfo if an instr was seen at that <code>pc</code> but there was a decoding error for the instruction.</p>
<p>Guaranteed to be non-nullptr and valid if the prior <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#a6435da335a7f8b80e2a17a97d1a34d6a">add_decode_info()</a> for that <code>pc</code> returned no error.</p>
<p>When analyzing <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">memref_t</a> from a trace, it may be better to just use <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#a6435da335a7f8b80e2a17a97d1a34d6a">add_decode_info()</a> instead (as it also returns the added DecodeInfo) if it's possible that the instr at <code>pc</code> may have changed (e.g., JIT code) in which case the cache will need to be updated. </p>

</div>
</div>
<a id="af5f9f72a3cb63055b5d5c790b83bf0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f9f72a3cb63055b5d5c790b83bf0e4">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DecodeInfo &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a>&lt; DecodeInfo &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedynamorio_1_1drmemtrace.html#a017717a4b9ef5ae1f6d1fef1df834baa">offline_file_type_t</a>&#160;</td>
          <td class="paramname"><em>filetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>module_file_path</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alt_module_dir</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs initialization tasks such as verifying whether the given trace indeed has embedded encodings or not, and initializing the <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">dynamorio::drmemtrace::module_mapper_t</a> if the module path is provided.</p>
<p>It is important to note some nuances in how the filetype can be obtained:</p><ul>
<li>the trace filetype may be obtained using the get_filetype() API on the <a class="el" href="classdynamorio_1_1drmemtrace_1_1memtrace__stream__t.html">dynamorio::drmemtrace::memtrace_stream_t</a>. However, instances of <a class="el" href="classdynamorio_1_1drmemtrace_1_1memtrace__stream__t.html">dynamorio::drmemtrace::memtrace_stream_t</a> have the filetype available at init time (in the <a class="el" href="classdynamorio_1_1drmemtrace_1_1analysis__tool__tmpl__t.html#a16ba77b9899dde9627e9383ca587af79">dynamorio::drmemtrace::analysis_tool_t::initialize()</a> or <a class="el" href="classdynamorio_1_1drmemtrace_1_1analysis__tool__tmpl__t.html#a71607218331f15e9882ed527a9654d69">dynamorio::drmemtrace::analysis_tool_t::initialize_stream()</a> functions) only for offline analysis, not for online analysis.</li>
<li>when using the -skip_instrs or -skip_timestamp analyzer options, all initial header entries are skipped over. Therefore, the analysis tool may not see a <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295cacd29def39c2dd6b8dfc0e3976ce59d3d">TRACE_MARKER_TYPE_FILETYPE</a> at all.</li>
</ul>
<p>The most reliable way to obtain the filetype (and call this <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html#af5f9f72a3cb63055b5d5c790b83bf0e4">init()</a> API), would be to use <a class="el" href="classdynamorio_1_1drmemtrace_1_1memtrace__stream__t.html#a30d3ae86496bd7fda94f4db586a46f3d">dynamorio::drmemtrace::memtrace_stream_t::get_filetype()</a> just before processing the first instruction memref in the <a class="el" href="classdynamorio_1_1drmemtrace_1_1analysis__tool__tmpl__t.html#a08ef7c28c3e029642f2408d58547c0f8">dynamorio::drmemtrace::analysis_tool_t::process_memref()</a> or <a class="el" href="classdynamorio_1_1drmemtrace_1_1analysis__tool__tmpl__t.html#ae5604598d12427c46f4682b7bd580c39">dynamorio::drmemtrace::analysis_tool_t::parallel_shard_memref()</a> APIs.</p>
<p>If the <code>module_file_path</code> parameter is not empty, it instructs the <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a> object that it should look for the instr encodings in the application binaries using a <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">dynamorio::drmemtrace::module_mapper_t</a>. A <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">dynamorio::drmemtrace::module_mapper_t</a> is instantiated only one time and reused for all objects of <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a> (of any template type). The user must provide a valid <code>module_file_path</code> if decoding instructions from a trace that does not have embedded instruction encodings in it, as indicated by absence of the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a017717a4b9ef5ae1f6d1fef1df834baaa1bc66b6cb976d3bb7f93af0ce5d2ec53">OFFLINE_FILE_TYPE_ENCODINGS</a> bit in the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295cacd29def39c2dd6b8dfc0e3976ce59d3d">TRACE_MARKER_TYPE_FILETYPE</a> marker. The user may provide a <code>module_file_path</code> also if they deliberately need to use the module mapper instead of the embedded encodings. Each instance of <a class="el" href="classdynamorio_1_1drmemtrace_1_1decode__cache__t.html">dynamorio::drmemtrace::decode_cache_t</a> must be initialized with either an empty <code>module_file_path</code>, or the same one as other instances that also specified a non-empty path (even the ones in other analysis tools).</p>
<p>If the provided <code>module_file_path</code> is empty, the cache object uses the encodings embedded in the trace records.</p>
<p>This also sets the isa_mode in dcontext based on the arch bits in the provided <code>filetype</code>, unless the instance was not asked to include decoded instructions via the <code>include_decoded_instr_</code> param to the constructor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/dynamorio/dynamorio/build_release-64/clients/include/drmemtrace/decode_cache.h</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 11.90.20468 --- Fri Jan 16 2026 03:34:33 &nbsp; <img border=0 src="favicon.png">
</small></address>
